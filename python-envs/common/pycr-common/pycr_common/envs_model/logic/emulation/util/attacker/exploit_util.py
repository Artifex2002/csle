from typing import Tuple
import time
import paramiko
from gym_pycr_ctf.dao.network.env_config import EnvConfig
from gym_pycr_ctf.dao.action.attacker.attacker_action import AttackerAction
from gym_pycr_ctf.dao.network.env_state import EnvState
from gym_pycr_ctf.envs_model.logic.common.env_dynamics_util import EnvDynamicsUtil
from pycr_common.dao.observation.common.connection_observation_state import ConnectionObservationState
from gym_pycr_ctf.dao.observation.attacker.attacker_machine_observation_state import AttackerMachineObservationState
from pycr_common.dao.observation.common.vulnerability_observation_state import VulnerabilityObservationState
import pycr_common.constants.constants as constants
from pycr_common.dao.network.transport_protocol import TransportProtocol
from pycr_common.dao.network.credential import Credential
from pycr_common.envs_model.logic.emulation.util.common.emulation_util import EmulationUtil
from pycr_common.envs_model.logic.emulation.util.common.connection_util import ConnectionUtil


class ExploitUtil:
    """
    Class containing utility functions for the exploit-related functionality to the emulation
    """

    @staticmethod
    def sambacry_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Helper for executing the SambaCry exploit action

        :param s: the current state
        :param a: the SambaCry exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = AttackerMachineObservationState(ip=a.ip)

        jump_connection = ConnectionUtil.find_jump_host_connection(ip=target_machine.ip, s=s, env_config=env_config)
        base_cache_id = (a.id, a.index, a.ip, a.subnet, jump_connection.username)
        cache_key = base_cache_id
        exploit_successful = False

        # Check cache first
        cache_hit = False
        cost = 0
        total_alerts = (0, 0)
        if env_config.attacker_use_user_command_cache:

            # Check in-memory cache
            if env_config.attacker_user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful = env_config.attacker_user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = EmulationUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                   user=jump_connection.username,
                                                                   jumphost=jump_connection.ip)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = EmulationUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                      conn=env_config.emulation_config.agent_conn)
                    # Use measured cost
                    if env_config.attacker_action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                                    user=constants.SAMBA.BACKDOOR_USER,
                                                                    service=constants.SAMBA.SERVICE_NAME):
                        a.cost = env_config.attacker_action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=constants.SAMBA.BACKDOOR_USER,
                            service=constants.SAMBA.SERVICE_NAME)
                        cost = a.cost
                    else:
                        cost = 0

                    if int(cache_res) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.SAMBA.BACKDOOR_USER, pw=constants.SAMBA.BACKDOOR_PW,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = VulnerabilityObservationState(
                            name=constants.EXPLOIT_VULNERABILITES.SAMBACRY_EXPLOIT,
                            cvss=9.8,
                            credentials=[Credential(username=constants.SAMBA.BACKDOOR_USER,
                                                    pw=constants.SAMBA.BACKDOOR_PW,
                                                    port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                    service=constants.SSH.SERVICE_NAME),
                                         credential
                                         ], port=constants.SAMBA.PORT, protocol=TransportProtocol.TCP,
                            service=constants.SAMBA.SERVICE_NAME)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.attacker_action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                                    user=constants.SAMBA.BACKDOOR_USER,
                                                                    service=constants.SAMBA.SERVICE_NAME):
                    a.alerts = env_config.attacker_action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                                   user=constants.SAMBA.BACKDOOR_USER,
                                                                                   service=constants.SAMBA.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:
            for i in range(env_config.attacker_retry_sambacry):
                # Try execute exploit from jumphost
                cost = 0
                total_alerts = (0, 0)
                if env_config.ids_router:
                    last_alert_ts = EmulationUtil.get_latest_alert_ts(env_config=env_config)
                cmd = a.cmd[0]
                cmd = cmd.format(a.ip)
                outdata, errdata, total_time = EmulationUtil.execute_ssh_cmd(
                    cmd=cmd, conn=jump_connection.conn)

                # Parse result and check outcome
                exploit_successful = constants.SAMBA.ALREADY_EXISTS in outdata.decode() or \
                                     (constants.SAMBA.ERROR not in outdata.decode()
                                      and constants.SAMBA.ERROR not in errdata.decode()
                                      and constants.SAMBA.AUTH_OK in outdata.decode())

                if exploit_successful:
                    break
                else:
                    time.sleep(env_config.attacker_sambacry_sleep_retry)

            # Parse Result
            if exploit_successful:

                # Exploit successful
                credential = Credential(username=constants.SAMBA.BACKDOOR_USER, pw=constants.SAMBA.BACKDOOR_PW,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = VulnerabilityObservationState(
                    name=constants.EXPLOIT_VULNERABILITES.SAMBACRY_EXPLOIT,
                    cvss=9.8,
                    credentials=[Credential(username=constants.SAMBA.BACKDOOR_USER, pw=constants.SAMBA.BACKDOOR_PW,
                                            port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                            service=constants.SSH.SERVICE_NAME)
                                 ], port=constants.SAMBA.PORT, protocol=TransportProtocol.TCP,
                service=constants.SAMBA.SERVICE_NAME)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = EmulationUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                EmulationUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                    action=a, env_config=env_config,
                                                    user=constants.SAMBA.BACKDOOR_USER,
                                                    service=constants.SAMBA.SERVICE_NAME,
                                                    conn=env_config.emulation_config.agent_conn)
                env_config.attacker_action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                                    alert=(sum_priority_alerts, num_alerts),
                                                                    user=constants.SAMBA.BACKDOOR_USER,
                                                                    service=constants.SAMBA.SERVICE_NAME)

            EmulationUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                               user=constants.SAMBA.BACKDOOR_USER,
                                               service=constants.SAMBA.SERVICE_NAME,
                                               conn=env_config.emulation_config.agent_conn)
            env_config.attacker_action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                           user=constants.SAMBA.BACKDOOR_USER,
                                                           service=constants.SAMBA.SERVICE_NAME)

            # Persist cache result
            EmulationUtil.write_user_command_cache(action=a, env_config=env_config,
                                                   user=jump_connection.username,
                                                   result=str(int(exploit_successful)), ip=a.ip,
                                                   jumphost=jump_connection.ip)

        # Update cache
        if env_config.attacker_use_user_command_cache:
            env_config.attacker_user_command_cache.add(cache_key, (target_machine.copy(), cost, exploit_successful))

        target_machine.sambacry_tried = True

        net_outcome = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, [target_machine.copy()],
                                                             env_config=env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = net_outcome.attacker_machine_observations

        reward = EnvDynamicsUtil.reward_function(net_outcome=net_outcome, env_config=env_config, action=a)

        # Emulate detection
        done, d_reward = EnvDynamicsUtil.emulate_detection(net_outcome=net_outcome, action=a, env_config=env_config)
        if done:
            reward = d_reward
        s_prime.attacker_obs_state.detected = done

        return s_prime, reward, done

    @staticmethod
    def shellshock_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Helper for executing the ShellShock exploit action

        :param s: the current state
        :param a: the Shellshock exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = AttackerMachineObservationState(ip=a.ip)

        jump_connection = ConnectionUtil.find_jump_host_connection(ip=target_machine.ip, s=s, env_config=env_config)
        base_cache_id = (a.id, a.index, a.ip, a.subnet, jump_connection.username)
        cache_key = base_cache_id
        exploit_successful = False

        # Check cache first
        cache_hit = False
        cost = 0
        total_alerts = (0, 0)
        if env_config.attacker_use_user_command_cache:

            # Check in-memory cache
            if env_config.attacker_user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful = env_config.attacker_user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = EmulationUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                   user=jump_connection.username,
                                                                   jumphost=jump_connection.ip)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = EmulationUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                      conn=env_config.emulation_config.agent_conn)
                    # Use measured cost
                    if env_config.attacker_action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.SHELLSHOCK.SERVICE_NAME):
                        a.cost = env_config.attacker_action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=env_config.emulation_config.agent_username,
                            service=constants.SHELLSHOCK.SERVICE_NAME)
                        cost = a.cost

                    if int(cache_res) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.SHELLSHOCK.BACKDOOR_USER,
                                                pw=constants.SHELLSHOCK.BACKDOOR_PW,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = VulnerabilityObservationState(
                            name=constants.EXPLOIT_VULNERABILITES.SHELLSHOCK_EXPLOIT,
                            cvss=9.8,
                            credentials=[Credential(username=constants.SHELLSHOCK.BACKDOOR_USER,
                                                    pw=constants.SHELLSHOCK.BACKDOOR_PW,
                                                    port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                    service=constants.SSH.SERVICE_NAME)
                                         ], port=constants.SHELLSHOCK.PORT, protocol=TransportProtocol.TCP,
                        service=constants.SHELLSHOCK.SERVICE_NAME)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.attacker_action_alerts.user_ip_exists(
                        action_id=a.id, ip=a.ip,
                        user=env_config.emulation_config.agent_username,
                        service=constants.SHELLSHOCK.SERVICE_NAME):
                    a.alerts = env_config.attacker_action_alerts.user_ip_get_alert(
                        action_id=a.id, ip=a.ip,
                        user=env_config.emulation_config.agent_username,
                        service=constants.SHELLSHOCK.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:

            for i in range(env_config.attacker_retry_shellshock):
                # Try execute exploit from jumphost
                cost = 0
                total_alerts = (0, 0)
                if env_config.ids_router:
                    last_alert_ts = EmulationUtil.get_latest_alert_ts(env_config=env_config)
                cmd = a.cmd[0]
                cmd = cmd.format(constants.SHELLSHOCK.BACKDOOR_USER, constants.SHELLSHOCK.BACKDOOR_PW,
                                 constants.SHELLSHOCK.BACKDOOR_USER, a.ip)
                outdata, errdata, total_time = EmulationUtil.execute_ssh_cmd(
                    cmd=cmd, conn=jump_connection.conn)

                cmd = a.cmd[1]
                cmd = cmd.format(constants.SHELLSHOCK.BACKDOOR_USER, constants.SHELLSHOCK.BACKDOOR_PW, a.ip)
                outdata1, errdata1, total_time1 = EmulationUtil.execute_ssh_cmd(
                    cmd=cmd, conn=jump_connection.conn)
                total_time = total_time + total_time1

                # Parse Result
                proxy_conn = ConnectionObservationState(conn=jump_connection.conn,
                                                        username=jump_connection.username,
                                                        root=True, port=22, service=constants.SSH.SERVICE_NAME,
                                                        proxy=None, ip=env_config.emulation_config.agent_ip)
                exploit_successful = ExploitUtil.check_if_rce_exploit_succeeded(user=constants.SHELLSHOCK.BACKDOOR_USER,
                                                                                pw=constants.SHELLSHOCK.BACKDOOR_PW,
                                                                                source_ip=jump_connection.ip,
                                                                                port=constants.SSH.DEFAULT_PORT,
                                                                                target_ip=a.ip,
                                                                                proxy_conn=proxy_conn)

                if exploit_successful:
                    break
                else:
                    time.sleep(env_config.attacker_shellshock_sleep_retry)

            if exploit_successful:

                # Exploit successful
                credential = Credential(username=constants.SHELLSHOCK.BACKDOOR_USER,
                                        pw=constants.SHELLSHOCK.BACKDOOR_PW,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = VulnerabilityObservationState(
                    name=constants.EXPLOIT_VULNERABILITES.SHELLSHOCK_EXPLOIT,
                    cvss=9.8,
                    credentials=[Credential(username=constants.SHELLSHOCK.BACKDOOR_USER,
                                            pw=constants.SHELLSHOCK.BACKDOOR_PW,
                                            port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                            service=constants.SSH.SERVICE_NAME)
                                 ], port=constants.SHELLSHOCK.PORT, protocol=TransportProtocol.TCP,
                service=constants.SHELLSHOCK.SERVICE_NAME)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = EmulationUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                EmulationUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                    action=a, env_config=env_config,
                                                    user=env_config.emulation_config.agent_username,
                                                    service=constants.SHELLSHOCK.SERVICE_NAME)
                env_config.attacker_action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                                    alert=(sum_priority_alerts, num_alerts),
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.SHELLSHOCK.SERVICE_NAME)

            EmulationUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                               user=env_config.emulation_config.agent_username,
                                               service=constants.SHELLSHOCK.SERVICE_NAME)
            env_config.attacker_action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                           user=env_config.emulation_config.agent_username,
                                                           service=constants.SHELLSHOCK.SERVICE_NAME)

            # Persist cache result
            EmulationUtil.write_user_command_cache(action=a, env_config=env_config,
                                                   user=jump_connection.username,
                                                   result=str(int(exploit_successful)), ip=a.ip,
                                                   jumphost=jump_connection.ip)

        # Update cache
        if env_config.attacker_use_user_command_cache:
            env_config.attacker_user_command_cache.add(cache_key, (target_machine.copy(), cost, exploit_successful))

        target_machine.shellshock_tried = True

        net_outcome = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, [target_machine.copy()],
                                                             env_config=env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = net_outcome.attacker_machine_observations

        reward = EnvDynamicsUtil.reward_function(net_outcome=net_outcome, env_config=env_config, action=a)

        # Emulate detection
        done, d_reward = EnvDynamicsUtil.emulate_detection(net_outcome=net_outcome, action=a, env_config=env_config)
        if done:
            reward = d_reward
        s_prime.attacker_obs_state.detected = done

        return s_prime, reward, done

    @staticmethod
    def check_if_rce_exploit_succeeded(user: str, pw: str, source_ip: str, port: int, target_ip: str,
                                       proxy_conn) -> bool:
        """
        Utility function for checking if a RCE exploit succeeded or not, i.e. if we got shell access

        :param user: the user that should have access
        :param pw: the password
        :param source_ip: the ip of the source node of the attack
        :param port: the port on the target
        :param target_ip: the target ip
        :param proxy_conn: optional proxy connection (jumphost)
        :return: True if the exploit succeeded, otherwise false
        """
        agent_addr = (source_ip, port)
        target_addr = (target_ip, port)
        agent_transport = proxy_conn.conn.get_transport()
        try:
            relay_channel = agent_transport.open_channel(constants.SSH.DIRECT_CHANNEL, target_addr, agent_addr,
                                                         timeout=3)
            target_conn = paramiko.SSHClient()
            target_conn.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            target_conn.connect(target_ip, username=user, password=pw, sock=relay_channel,
                                timeout=3)
            return True
        except Exception as e:
            return False

    @staticmethod
    def dvwa_sql_injection_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Helper for executing the DVWA SQL Injection exploit action

        :param s: the current state
        :param a: the DVWA SQL Injection exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        target_machine = AttackerMachineObservationState(ip=a.ip)

        jump_connection = ConnectionUtil.find_jump_host_connection(ip=target_machine.ip, s=s, env_config=env_config)
        base_cache_id = (a.id, a.index, a.ip, a.subnet, jump_connection.username)
        cache_key = base_cache_id
        exploit_successful = False
        pw = "-"

        # Check cache first
        cache_hit = False
        cost = 0
        total_alerts = (0, 0)
        if env_config.attacker_use_user_command_cache:

            # Check in-memory cache
            if env_config.attacker_user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful, pw = env_config.attacker_user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = EmulationUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                   user=jump_connection.username,
                                                                   jumphost=jump_connection.ip)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = EmulationUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                      conn=env_config.emulation_config.agent_conn)
                    cache_res_parts = cache_res.split(",")
                    cache_res_outcome = cache_res_parts[0]
                    cache_res_pw = cache_res_parts[1]
                    # Use measured cost
                    if env_config.attacker_action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.DVWA_SQL_INJECTION.SERVICE_NAME):
                        a.cost = env_config.attacker_action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=env_config.emulation_config.agent_username,
                            service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
                        cost = a.cost

                    if int(cache_res_outcome) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.DVWA_SQL_INJECTION.EXPLOIT_USER,
                                                pw=cache_res_pw,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = VulnerabilityObservationState(
                            name=constants.EXPLOIT_VULNERABILITES.DVWA_SQL_INJECTION,
                            cvss=9.8,
                            credentials=[Credential(username=constants.DVWA_SQL_INJECTION.EXPLOIT_USER,
                                                    pw=cache_res_pw,
                                                    port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                    service=constants.SSH.SERVICE_NAME)
                                         ], port=constants.DVWA_SQL_INJECTION.PORT, protocol=TransportProtocol.TCP,
                        service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)
                        pw = cache_res_pw

            if cache_hit:
                # Use measured # alerts
                if env_config.attacker_action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.DVWA_SQL_INJECTION.SERVICE_NAME):
                    a.alerts = env_config.attacker_action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                                   user=env_config.emulation_config.agent_username,
                                                                                   service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:

            for i in range(env_config.attacker_retry_dvwa_sql_injection):

                # Try execute exploit from agent host
                cost = 0
                total_alerts = (0, 0)
                if env_config.ids_router:
                    last_alert_ts = EmulationUtil.get_latest_alert_ts(env_config=env_config)
                cmd = a.cmd[0]
                cmd = cmd + " " + a.ip
                outdata, errdata, total_time = EmulationUtil.execute_ssh_cmd(
                    cmd=cmd, conn=jump_connection.conn)

                # Parse Result
                exploit_successful = False
                dir = "/home/" + jump_connection.username + "/"
                try:
                    exploit_result = ExploitUtil.read_dvwa_sql_injection_result(conn=jump_connection.conn,
                                                                                env_config=env_config,
                                                                                dir=dir)
                    pw = exploit_result[
                         exploit_result.find("pablo:") + 6: exploit_result.find("pablo:") + 6 + exploit_result[
                                                                                                exploit_result.find(
                                                                                                    "pablo:") + 6:].find(
                             "<")]
                    if "0d107" in pw:
                        exploit_successful = True
                    else:
                        exploit_successful = False
                        pw = "-"
                except Exception as e:
                    # print("SQL Injection Failed: {}".format(str(e)))
                    exploit_successful = False
                    pw = "-"

                if exploit_successful:
                    break
                else:
                    time.sleep(env_config.attacker_dvwa_sql_injection_sleep_retry)

            if exploit_successful:
                ExploitUtil.remove_dvwa_sql_injection_result(conn=jump_connection.conn,
                                                             env_config=env_config,
                                                             dir=dir)
                # Exploit successful
                credential = Credential(username=constants.DVWA_SQL_INJECTION.EXPLOIT_USER,
                                        pw=pw,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = VulnerabilityObservationState(
                    name=constants.EXPLOIT_VULNERABILITES.DVWA_SQL_INJECTION,
                    cvss=9.8,
                    credentials=[Credential(username=constants.DVWA_SQL_INJECTION.EXPLOIT_USER,
                                            pw=pw,
                                            port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                            service=constants.SSH.SERVICE_NAME)
                                 ], port=constants.DVWA_SQL_INJECTION.PORT, protocol=TransportProtocol.TCP,
                    service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)
                exploit_successful = True

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = EmulationUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                EmulationUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                    action=a, env_config=env_config,
                                                    user=env_config.emulation_config.agent_username,
                                                    service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
                env_config.attacker_action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                                    alert=(sum_priority_alerts, num_alerts),
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)

            EmulationUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                               user=env_config.emulation_config.agent_username,
                                               service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
            env_config.attacker_action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                           user=env_config.emulation_config.agent_username,
                                                           service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)

            # Persist cache result
            EmulationUtil.write_user_command_cache(action=a, env_config=env_config,
                                                   user=jump_connection.username,
                                                   result=str(int(exploit_successful)) + "," + pw, ip=a.ip,
                                                   jumphost=jump_connection.ip)

        # Update cache
        if env_config.attacker_use_user_command_cache:
            env_config.attacker_user_command_cache.add(cache_key, (target_machine.copy(), cost, exploit_successful, pw))

        target_machine.dvwa_sql_injection_tried = True

        net_outcome = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, [target_machine.copy()],
                                                             env_config=env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = net_outcome.attacker_machine_observations

        reward = EnvDynamicsUtil.reward_function(net_outcome=net_outcome, env_config=env_config, action=a)

        # Emulate detection
        done, d_reward = EnvDynamicsUtil.emulate_detection(net_outcome=net_outcome, action=a, env_config=env_config)
        if done:
            reward = d_reward
        s_prime.attacker_obs_state.detected = done

        return s_prime, reward, done

    @staticmethod
    def read_dvwa_sql_injection_result(conn, env_config: EnvConfig, dir: str) -> str:
        """
        Reads the result of a DVWA SQL Injection Attack
        :param conn: connection to use for reading
        :param env_config: environment config
        :param dir: the dir to check
        :return: the read result
        """
        sftp_client = conn.open_sftp()
        remote_file = sftp_client.open(dir + constants.DVWA_SQL_INJECTION.EXPLOIT_OUTPUT_FILENAME)
        result = None
        try:
            data = remote_file.read()
            result = data.decode()
        finally:
            remote_file.close()
        return result

    @staticmethod
    def remove_dvwa_sql_injection_result(conn, env_config: EnvConfig, dir: str) -> None:
        """
        Remove the result of a DVWA SQL Injection Attack
        :param conn: connection to use for the removal
        :param env_config: environment config
        :param dir: the directory where the file is
        :return: None
        """
        sftp_client = conn.open_sftp()
        sftp_client.remove(dir + constants.DVWA_SQL_INJECTION.EXPLOIT_OUTPUT_FILENAME)

    @staticmethod
    def cve_2015_3306_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Helper for executing the CVE-2015-3306 exploit action

        :param s: the current state
        :param a: the CVE-2015-3306 exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = AttackerMachineObservationState(ip=a.ip)

        jump_connection = ConnectionUtil.find_jump_host_connection(ip=target_machine.ip, s=s, env_config=env_config)
        base_cache_id = (a.id, a.index, a.ip, a.subnet, jump_connection.username)
        cache_key = base_cache_id
        exploit_successful = False

        # Check cache first
        cache_hit = False
        cost = 0
        total_alerts = (0, 0)
        if env_config.attacker_use_user_command_cache:

            # Check in-memory cache
            if env_config.attacker_user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful = env_config.attacker_user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = EmulationUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                   user=jump_connection.username,
                                                                   jumphost=jump_connection.ip)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = EmulationUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                      conn=env_config.emulation_config.agent_conn)
                    # Use measured cost
                    if env_config.attacker_action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.CVE_2015_3306.SERVICE_NAME):
                        a.cost = env_config.attacker_action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=env_config.emulation_config.agent_username,
                            service=constants.CVE_2015_3306.SERVICE_NAME)
                        cost = a.cost

                    if int(cache_res) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.CVE_2015_3306.BACKDOOR_USER,
                                                pw=constants.CVE_2015_3306.BACKDOOR_PW,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = VulnerabilityObservationState(
                            name=constants.EXPLOIT_VULNERABILITES.CVE_2015_3306,
                            cvss=9.8,
                            credentials=[Credential(username=constants.CVE_2015_3306.BACKDOOR_USER,
                                                    pw=constants.CVE_2015_3306.BACKDOOR_PW,
                                                    port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                    service=constants.SSH.SERVICE_NAME)
                                         ], port=constants.CVE_2015_3306.PORT, protocol=TransportProtocol.TCP,
                        service=constants.CVE_2015_3306.SERVICE_NAME)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.attacker_action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.CVE_2015_3306.SERVICE_NAME):
                    a.alerts = env_config.attacker_action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                                   user=env_config.emulation_config.agent_username,
                                                                                   service=constants.CVE_2015_3306.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:

            for i in range(env_config.attacker_retry_cve_2015_3306):

                # Try execute exploit from jumphost
                cost = 0
                total_alerts = (0, 0)
                if env_config.ids_router:
                    last_alert_ts = EmulationUtil.get_latest_alert_ts(env_config=env_config)
                cmd = a.cmd[0]
                cmd = cmd.format(a.ip)
                outdata, errdata, total_time = EmulationUtil.execute_ssh_cmd(
                    cmd=cmd, conn=jump_connection.conn)

                # Parse Result
                proxy_conn = ConnectionObservationState(conn=jump_connection.conn,
                                                        username=jump_connection.username,
                                                        root=True, port=22, service=constants.SSH.SERVICE_NAME,
                                                        proxy=None, ip=env_config.emulation_config.agent_ip)

                exploit_successful = ExploitUtil.check_if_rce_exploit_succeeded(user=constants.CVE_2015_3306.BACKDOOR_USER,
                                                                                pw=constants.CVE_2015_3306.BACKDOOR_PW,
                                                                                source_ip=jump_connection.ip,
                                                                                port=constants.SSH.DEFAULT_PORT,
                                                                                target_ip=a.ip,
                                                                                proxy_conn=proxy_conn)

                if exploit_successful:
                    break
                else:
                    time.sleep(env_config.attacker_cve_2015_3306_sleep_retry)


            if exploit_successful:

                # Exploit successful
                credential = Credential(username=constants.CVE_2015_3306.BACKDOOR_USER,
                                        pw=constants.CVE_2015_3306.BACKDOOR_PW,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = VulnerabilityObservationState(
                    name=constants.EXPLOIT_VULNERABILITES.CVE_2015_3306,
                    cvss=9.8,
                    credentials=[Credential(username=constants.CVE_2015_3306.BACKDOOR_USER,
                                            pw=constants.CVE_2015_3306.BACKDOOR_PW,
                                            port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                            service=constants.SSH.SERVICE_NAME)
                                 ], port=constants.CVE_2015_3306.PORT, protocol=TransportProtocol.TCP,
                service=constants.CVE_2015_3306.SERVICE_NAME)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)
                exploit_successful = True

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = EmulationUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                EmulationUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                    action=a, env_config=env_config,
                                                    user=env_config.emulation_config.agent_username,
                                                    service=constants.CVE_2015_3306.SERVICE_NAME)
                env_config.attacker_action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                                    alert=(sum_priority_alerts, num_alerts),
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.CVE_2015_3306.SERVICE_NAME)

            EmulationUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                               user=env_config.emulation_config.agent_username,
                                               service=constants.CVE_2015_3306.SERVICE_NAME)
            env_config.attacker_action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                           user=env_config.emulation_config.agent_username,
                                                           service=constants.CVE_2015_3306.SERVICE_NAME)

            # Persist cache result
            EmulationUtil.write_user_command_cache(action=a, env_config=env_config,
                                                   user=jump_connection.username,
                                                   result=str(int(exploit_successful)), ip=a.ip,
                                                   jumphost=jump_connection.ip)

        # Update cache
        if env_config.attacker_use_user_command_cache:
            env_config.attacker_user_command_cache.add(cache_key, (target_machine.copy(), cost, exploit_successful))

        target_machine.cve_2015_3306_tried = True

        net_outcome = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, [target_machine.copy()],
                                                             env_config=env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = net_outcome.attacker_machine_observations

        reward = EnvDynamicsUtil.reward_function(net_outcome=net_outcome, env_config=env_config, action=a)

        # Emulate detection
        done, d_reward = EnvDynamicsUtil.emulate_detection(net_outcome=net_outcome, action=a, env_config=env_config)
        if done:
            reward = d_reward
        s_prime.attacker_obs_state.detected = done

        return s_prime, reward, done

    @staticmethod
    def cve_2015_1427_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Helper for executing the CVE-2015-1427 exploit action

        :param s: the current state
        :param a: the CVE-2015-1427 exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = AttackerMachineObservationState(ip=a.ip)

        jump_connection = ConnectionUtil.find_jump_host_connection(ip=target_machine.ip, s=s, env_config=env_config)
        base_cache_id = (a.id, a.index, a.ip, a.subnet, jump_connection.username)
        cache_key = base_cache_id
        exploit_successful = False

        # Check cache first
        cache_hit = False
        cost = 0
        total_alerts = (0, 0)
        if env_config.attacker_use_user_command_cache:

            # Check in-memory cache
            if env_config.attacker_user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful = env_config.attacker_user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = EmulationUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                   user=jump_connection.username,
                                                                   jumphost=jump_connection.ip)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = EmulationUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                      conn=env_config.emulation_config.agent_conn)
                    # Use measured cost
                    if env_config.attacker_action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.CVE_2015_1427.SERVICE_NAME):
                        a.cost = env_config.attacker_action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=env_config.emulation_config.agent_username,
                            service=constants.CVE_2015_1427.SERVICE_NAME)
                        cost = a.cost

                    if int(cache_res) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.CVE_2015_1427.BACKDOOR_USER,
                                                pw=constants.CVE_2015_1427.BACKDOOR_PW,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = VulnerabilityObservationState(
                            name=constants.EXPLOIT_VULNERABILITES.CVE_2015_1427,
                            cvss=9.8,
                            credentials=[Credential(username=constants.CVE_2015_1427.BACKDOOR_USER,
                                                    pw=constants.CVE_2015_1427.BACKDOOR_PW,
                                                    port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                    service=constants.SSH.SERVICE_NAME)
                                         ], port=constants.CVE_2015_1427.PORT, protocol=TransportProtocol.TCP,
                        service=constants.CVE_2015_1427.SERVICE_NAME)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.attacker_action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.CVE_2015_1427.SERVICE_NAME):
                    a.alerts = env_config.attacker_action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                                   user=env_config.emulation_config.agent_username,
                                                                                   service=constants.CVE_2015_1427.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:

            for i in range(env_config.attacker_retry_cve_2015_1427):

                # Try execute exploit from jumphost
                cost = 0
                total_alerts = (0, 0)
                if env_config.ids_router:
                    last_alert_ts = EmulationUtil.get_latest_alert_ts(env_config=env_config)
                cmd = a.cmd[0]
                cmd = cmd.format(a.ip)
                outdata, errdata, total_time = EmulationUtil.execute_ssh_cmd(
                    cmd=cmd, conn=jump_connection.conn)

                # Parse Result
                proxy_conn = ConnectionObservationState(conn=jump_connection.conn,
                                                        username=jump_connection.username,
                                                        root=True, port=22, service=constants.SSH.SERVICE_NAME,
                                                        proxy=None, ip=env_config.emulation_config.agent_ip)

                exploit_successful = ExploitUtil.check_if_rce_exploit_succeeded(user=constants.CVE_2015_1427.BACKDOOR_USER,
                                                                                pw=constants.CVE_2015_1427.BACKDOOR_PW,
                                                                                source_ip=jump_connection.ip,
                                                                                port=constants.SSH.DEFAULT_PORT,
                                                                                target_ip=a.ip,
                                                                                proxy_conn=proxy_conn)

                if exploit_successful:
                    break
                else:
                    time.sleep(env_config.attacker_cve_2015_1427_sleep_retry)

            if exploit_successful:
                # Exploit successful
                credential = Credential(username=constants.CVE_2015_1427.BACKDOOR_USER,
                                        pw=constants.CVE_2015_1427.BACKDOOR_PW,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = VulnerabilityObservationState(
                    name=constants.EXPLOIT_VULNERABILITES.CVE_2015_1427,
                    cvss=9.8,
                    credentials=[Credential(username=constants.CVE_2015_1427.BACKDOOR_USER,
                                            pw=constants.CVE_2015_1427.BACKDOOR_PW,
                                            port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                            service=constants.SSH.SERVICE_NAME)
                                 ], port=constants.CVE_2015_1427.PORT, protocol=TransportProtocol.TCP,
                service=constants.CVE_2015_1427.SERVICE_NAME)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)
                exploit_successful = True

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = EmulationUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                EmulationUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                    action=a, env_config=env_config,
                                                    user=env_config.emulation_config.agent_username,
                                                    service=constants.CVE_2015_1427.SERVICE_NAME)
                env_config.attacker_action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                                    alert=(sum_priority_alerts, num_alerts),
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.CVE_2015_1427.SERVICE_NAME)

            EmulationUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                               user=env_config.emulation_config.agent_username,
                                               service=constants.CVE_2015_1427.SERVICE_NAME)
            env_config.attacker_action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                           user=env_config.emulation_config.agent_username,
                                                           service=constants.CVE_2015_1427.SERVICE_NAME)

            # Persist cache result
            EmulationUtil.write_user_command_cache(action=a, env_config=env_config,
                                                   user=jump_connection.username,
                                                   result=str(int(exploit_successful)), ip=a.ip,
                                                   jumphost=jump_connection.ip)

        # Update cache
        if env_config.attacker_use_user_command_cache:
            env_config.attacker_user_command_cache.add(cache_key, (target_machine.copy(), cost, exploit_successful))

        target_machine.cve_2015_1427_tried = True

        net_outcome = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, [target_machine.copy()],
                                                             env_config=env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = net_outcome.attacker_machine_observations

        reward = EnvDynamicsUtil.reward_function(net_outcome=net_outcome, env_config=env_config, action=a)

        # Emulate detection
        done, d_reward = EnvDynamicsUtil.emulate_detection(net_outcome=net_outcome, action=a, env_config=env_config)
        if done:
            reward = d_reward
        s_prime.attacker_obs_state.detected = done

        return s_prime, reward, done

    @staticmethod
    def cve_2016_10033_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Helper for executing the CVE-2016-10033 exploit action

        :param s: the current state
        :param a: the CVE-2016-10033 exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = AttackerMachineObservationState(ip=a.ip)

        jump_connection = ConnectionUtil.find_jump_host_connection(ip=target_machine.ip, s=s, env_config=env_config)
        base_cache_id = (a.id, a.index, a.ip, a.subnet, jump_connection.username)
        cache_key = base_cache_id
        exploit_successful = False

        # Check cache first
        cache_hit = False
        cost = 0
        total_alerts = (0, 0)
        if env_config.attacker_use_user_command_cache:

            # Check in-memory cache
            if env_config.attacker_user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful = env_config.attacker_user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = EmulationUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                   user=jump_connection.username,
                                                                   jumphost=jump_connection.ip)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = EmulationUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                      conn=env_config.emulation_config.agent_conn)
                    # Use measured cost
                    if env_config.attacker_action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.CVE_2016_10033.SERVICE_NAME):
                        a.cost = env_config.attacker_action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=env_config.emulation_config.agent_username,
                            service=constants.CVE_2016_10033.SERVICE_NAME)
                        cost = a.cost

                    if int(cache_res) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.CVE_2016_10033.BACKDOOR_USER,
                                                pw=constants.CVE_2016_10033.BACKDOOR_PW,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = VulnerabilityObservationState(
                            name=constants.EXPLOIT_VULNERABILITES.CVE_2016_10033,
                            cvss=9.8,
                            credentials=[Credential(username=constants.CVE_2016_10033.BACKDOOR_USER,
                                                    pw=constants.CVE_2016_10033.BACKDOOR_PW,
                                                    port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                    service=constants.SSH.SERVICE_NAME)
                                         ], port=constants.CVE_2016_10033.PORT, protocol=TransportProtocol.TCP,
                        service=constants.CVE_2016_10033.SERVICE_NAME)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.attacker_action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.CVE_2016_10033.SERVICE_NAME):
                    a.alerts = env_config.attacker_action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                                   user=env_config.emulation_config.agent_username,
                                                                                   service=constants.CVE_2016_10033.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:

            for i in range(env_config.attacker_retry_cve_2016_10033):

                # Try execute exploit from jumphost
                cost = 0
                total_alerts = (0, 0)
                if env_config.ids_router:
                    last_alert_ts = EmulationUtil.get_latest_alert_ts(env_config=env_config)
                cmd = a.cmd[0]
                cmd = cmd.format(a.ip)
                outdata, errdata, total_time = EmulationUtil.execute_ssh_cmd(
                    cmd=cmd, conn=jump_connection.conn)

                # Parse Result
                proxy_conn = ConnectionObservationState(conn=jump_connection.conn,
                                                        username=jump_connection.username,
                                                        root=True, port=22, service=constants.SSH.SERVICE_NAME,
                                                        proxy=None, ip=env_config.emulation_config.agent_ip)

                exploit_successful = ExploitUtil.check_if_rce_exploit_succeeded(user=constants.CVE_2016_10033.BACKDOOR_USER,
                                                                                pw=constants.CVE_2016_10033.BACKDOOR_PW,
                                                                                source_ip=jump_connection.ip,
                                                                                port=constants.SSH.DEFAULT_PORT,
                                                                                target_ip=a.ip,
                                                                                proxy_conn=proxy_conn)

                if exploit_successful:
                    break
                else:
                    time.sleep(env_config.attacker_cve_2016_10033_sleep_retry)

            if exploit_successful:
                # Exploit successful
                credential = Credential(username=constants.CVE_2016_10033.BACKDOOR_USER,
                                        pw=constants.CVE_2016_10033.BACKDOOR_PW,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = VulnerabilityObservationState(
                    name=constants.EXPLOIT_VULNERABILITES.CVE_2016_10033,
                    cvss=9.8,
                    credentials=[Credential(username=constants.CVE_2016_10033.BACKDOOR_USER,
                                            pw=constants.CVE_2016_10033.BACKDOOR_PW,
                                            port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                            service=constants.SSH.SERVICE_NAME)
                                 ], port=constants.CVE_2016_10033.PORT, protocol=TransportProtocol.TCP,
                service=constants.CVE_2016_10033.SERVICE_NAME)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)
                exploit_successful = True

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = EmulationUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                EmulationUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                    action=a, env_config=env_config,
                                                    user=env_config.emulation_config.agent_username,
                                                    service=constants.CVE_2016_10033.SERVICE_NAME)
                env_config.attacker_action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                                    alert=(sum_priority_alerts, num_alerts),
                                                                    user=env_config.emulation_config.agent_username,
                                                                    service=constants.CVE_2016_10033.SERVICE_NAME)

            EmulationUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                               user=env_config.emulation_config.agent_username,
                                               service=constants.CVE_2016_10033.SERVICE_NAME)
            env_config.attacker_action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                           user=env_config.emulation_config.agent_username,
                                                           service=constants.CVE_2016_10033.SERVICE_NAME)

            # Persist cache result
            EmulationUtil.write_user_command_cache(action=a, env_config=env_config,
                                                   user=jump_connection.username,
                                                   result=str(int(exploit_successful)), ip=a.ip,
                                                   jumphost=jump_connection.ip)

        # Update cache
        if env_config.attacker_use_user_command_cache:
            env_config.attacker_user_command_cache.add(cache_key, (target_machine.copy(), cost, exploit_successful))

        target_machine.cve_2016_10033_tried = True

        net_outcome = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, [target_machine.copy()],
                                                   env_config=env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = net_outcome.attacker_machine_observations

        reward = EnvDynamicsUtil.reward_function(net_outcome=net_outcome, env_config=env_config, action=a)

        # Emulate detection
        done, d_reward = EnvDynamicsUtil.emulate_detection(net_outcome=net_outcome, action=a, env_config=env_config)
        if done:
            reward = d_reward
        s_prime.attacker_obs_state.detected = done

        return s_prime, reward, done

    @staticmethod
    def cve_2010_0426_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig, machine: AttackerMachineObservationState,
                             result: AttackerMachineObservationState) \
            -> Tuple[AttackerMachineObservationState, float, Tuple[float, float], bool, Credential, str]:
        """
        Helper for executing the CVE-2010-0426 privelege_escalation action

        :param s: the current state
        :param a: the CVE-2010-0425 privilege escalation action
        :param env_config: the environment config
        :return: new_machine_obs, cost, alerts, successful, root_credential, service_name
        """
        proxy_conn = ConnectionUtil.find_jump_host_connection(ip=a.ip, s=s, env_config=env_config)
        cost = 0
        alerts = (0, 0)
        if env_config.ids_router:
            last_alert_ts = EmulationUtil.get_latest_alert_ts(env_config=env_config)
        e_succ = False
        root_credential = None
        service = None
        sleep_time = 0.5

        # Start with SSH connections
        for ssh_conn in machine.ssh_connections:

            for i in range(env_config.attacker_retry_cve_2010_0426):

                # Setup interactive shell
                channel = ssh_conn.conn.invoke_shell()

                # clear output
                if channel.recv_ready():
                    output = channel.recv(constants.COMMON.DEFAULT_RECV_SIZE)

                # Exploit
                cmd = a.cmd[0].format(constants.CVE_2010_0426.EXPLOIT_FILE)
                e_succ = False
                try:
                    EmulationUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                    time.sleep(sleep_time)
                    output = EmulationUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                    cmd = a.cmd[1]
                    EmulationUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                    time.sleep(sleep_time)
                    output = EmulationUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                    e_succ = ExploitUtil.check_if_rce_exploit_succeeded(
                        user=constants.CVE_2010_0426.BACKDOOR_USER, pw=constants.CVE_2010_0426.BACKDOOR_PW,
                        source_ip=env_config.emulation_config.agent_ip, port=constants.SSH.DEFAULT_PORT,
                        target_ip=a.ip, proxy_conn=proxy_conn)
                except Exception as e:
                    print("CVE-2010-0426 error:{}".format(str(e)))
                    e_succ = False

                if e_succ:
                    break
                else:
                    time.sleep(env_config.attacker_cve_2010_0426_sleep_retry)

            if e_succ:
                root_credential = Credential(username=constants.CVE_2010_0426.BACKDOOR_USER,
                                             pw=constants.CVE_2010_0426.BACKDOOR_PW, port=constants.SSH.DEFAULT_PORT,
                                             protocol=TransportProtocol.TCP, service=constants.SSH.SERVICE_NAME)
                root_connection = EmulationUtil.setup_custom_connection(
                    user=constants.CVE_2010_0426.BACKDOOR_USER, pw=constants.CVE_2010_0426.BACKDOOR_PW,
                    source_ip=env_config.emulation_config.agent_ip, port=constants.SSH.DEFAULT_PORT,
                    target_ip=machine.ip, proxy_conn=proxy_conn, root=True)
                vuln = VulnerabilityObservationState(
                    name=constants.EXPLOIT_VULNERABILITES.CVE_2010_0426,
                    cvss=6,
                    credentials=[root_credential], port=constants.SSH.DEFAULT_PORT,
                    protocol=TransportProtocol.TCP,
                service=root_credential.service)
                result.cve_vulns.append(vuln)
                result.cve_2010_0426_tried = True
                result.shell_access_credentials.append(root_credential)
                result.backdoor_credentials.append(root_credential)
                result.backdoor_tried = True
                result.backdoor_installed = True
                result.shell_access = True
                result.logged_in = True
                result.root = True
                result.ssh_connections.append(root_connection)
                service = constants.SSH.SERVICE_NAME
                break

                # Measure  cost and alerts
                cost += float(sleep_time * 2)
                if env_config.ids_router:
                    fast_logs = EmulationUtil.check_ids_fast_log(env_config=env_config)
                    if last_alert_ts is not None:
                        fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                    sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                    num_alerts = len(fast_logs)
                    alerts = (num_alerts, sum_priority_alerts)
                    EmulationUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                        action=a, env_config=env_config,
                                                        user=env_config.emulation_config.agent_username,
                                                        service=constants.CVE_2010_0426.SERVICE_NAME)
                    env_config.action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                               alert=(sum_priority_alerts, num_alerts),
                                                               user=env_config.emulation_config.agent_username,
                                                               service=constants.CVE_2010_0426.SERVICE_NAME)

                EmulationUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                                   user=env_config.emulation_config.agent_username,
                                                   service=constants.CVE_2010_0426.SERVICE_NAME)
                env_config.action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=cost,
                                                      user=env_config.emulation_config.agent_username,
                                                      service=constants.CVE_2010_0426.SERVICE_NAME)
        result.cve_2010_0426_tried = True
        return result, cost, alerts, e_succ, root_credential, service

    @staticmethod
    def cve_2015_5602_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig, machine: AttackerMachineObservationState,
                             result: AttackerMachineObservationState) \
            -> Tuple[AttackerMachineObservationState, float, Tuple[float, float], bool, Credential, str]:
        """
        Helper for executing the CVE-2015-5602 privilege escalation action

        :param s: the current state
        :param a: the CVE-2015-5602 privilege escalation action
        :param env_config: the environment config
        :return: s_prime, cost, alerts, e_succ (flag), credentials, servicename
        """
        proxy_conn = ConnectionUtil.find_jump_host_connection(ip=a.ip, s=s, env_config=env_config)
        cost = 0
        alerts = (0, 0)
        if env_config.ids_router:
            last_alert_ts = EmulationUtil.get_latest_alert_ts(env_config=env_config)
        e_succ = False
        root_credential = None
        service = None
        sleep_time = 0.5


        # Start with SSH connections
        for ssh_conn in machine.ssh_connections:

            for i in range(env_config.attacker_retry_cve_2015_5602):

                # Setup interactive shell
                channel = ssh_conn.conn.invoke_shell()

                # clear output
                if channel.recv_ready():
                    output = channel.recv(constants.COMMON.DEFAULT_RECV_SIZE)

                # Exploit
                cmd = a.cmd[0]
                e_succ = True
                try:
                    EmulationUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                    time.sleep(sleep_time)
                    output = EmulationUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                    cmd = a.cmd[1]
                    EmulationUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                    time.sleep(sleep_time)
                    output = EmulationUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                    cmd = a.cmd[2]
                    EmulationUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                    time.sleep(sleep_time)
                    output = EmulationUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                    cmd = a.cmd[3]
                    EmulationUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                    time.sleep(sleep_time)
                    output = EmulationUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                    e_succ = ExploitUtil.check_if_rce_exploit_succeeded(
                        user=constants.CVE_2015_5602.BACKDOOR_USER, pw=constants.CVE_2015_5602.BACKDOOR_PW,
                        source_ip=env_config.emulation_config.agent_ip, port=constants.SSH.DEFAULT_PORT,
                        target_ip=a.ip, proxy_conn=proxy_conn)
                except Exception as e:
                    print("CVE-2015-5602 error:{}".format(str(e)))
                    e_succ = False

                if e_succ:
                    break
                else:
                    time.sleep(env_config.attacker_cve_2015_5602_sleep_retry)

            if e_succ:
                root_credential = Credential(username=constants.CVE_2015_5602.BACKDOOR_USER,
                                             pw=constants.CVE_2015_5602.BACKDOOR_PW,
                                             port=constants.SSH.DEFAULT_PORT,
                                             protocol=TransportProtocol.TCP, service=constants.SSH.SERVICE_NAME)
                root_connection = EmulationUtil.setup_custom_connection(
                    user=constants.CVE_2015_5602.BACKDOOR_USER, pw=constants.CVE_2015_5602.BACKDOOR_PW,
                    source_ip=env_config.emulation_config.agent_ip, port=constants.SSH.DEFAULT_PORT,
                    target_ip=machine.ip, proxy_conn=proxy_conn, root=True)
                vuln = VulnerabilityObservationState(
                    name=constants.EXPLOIT_VULNERABILITES.CVE_2015_5602,
                    cvss=6,
                    credentials=[root_credential], port=constants.SSH.DEFAULT_PORT,
                    protocol=TransportProtocol.TCP, service = root_credential.service)
                result.cve_vulns.append(vuln)
                result.cve_2015_5602_tried = True
                result.shell_access_credentials.append(root_credential)
                result.backdoor_credentials.append(root_credential)
                result.backdoor_tried = True
                result.backdoor_installed = True
                result.shell_access = True
                result.logged_in = True
                result.root = True
                result.ssh_connections.append(root_connection)
                service = constants.SSH.SERVICE_NAME
                break

                # Measure  cost and alerts
                cost += float(sleep_time * 2)
                if env_config.ids_router:
                    fast_logs = EmulationUtil.check_ids_fast_log(env_config=env_config)
                    if last_alert_ts is not None:
                        fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                    sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                    num_alerts = len(fast_logs)
                    alerts = (num_alerts, sum_priority_alerts)
                    EmulationUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                        action=a, env_config=env_config,
                                                        user=env_config.emulation_config.agent_username,
                                                        service=constants.CVE_2015_5602.SERVICE_NAME)
                    env_config.action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                               alert=(sum_priority_alerts, num_alerts),
                                                               user=env_config.emulation_config.agent_username,
                                                               service=constants.CVE_2015_5602.SERVICE_NAME)

                EmulationUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                                   user=env_config.emulation_config.agent_username,
                                                   service=constants.CVE_2015_5602.SERVICE_NAME)
                env_config.action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=cost,
                                                      user=env_config.emulation_config.agent_username,
                                                      service=constants.CVE_2015_5602.SERVICE_NAME)
        result.cve_2015_5602_tried = True
        return result, cost, alerts, e_succ, root_credential, service