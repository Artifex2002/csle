from typing import Tuple
from gym_pycr_pwcrack.dao.network.env_state import EnvState
from gym_pycr_pwcrack.dao.network.env_config import EnvConfig
from gym_pycr_pwcrack.dao.action.action import Action
from gym_pycr_pwcrack.envs.logic.cluster.util.cluster_util import ClusterUtil
from gym_pycr_pwcrack.dao.observation.machine_observation_state import MachineObservationState
from gym_pycr_pwcrack.envs.logic.common.env_dynamics_util import EnvDynamicsUtil
from gym_pycr_pwcrack.dao.network.credential import Credential
from gym_pycr_pwcrack.dao.network.transport_protocol import TransportProtocol
from gym_pycr_pwcrack.dao.network.vulnerability import Vulnerability
from gym_pycr_pwcrack.dao.observation.connection_observation_state import ConnectionObservationState
import gym_pycr_pwcrack.constants.constants as constants
from gym_pycr_pwcrack.envs.logic.cluster.util.nmap_util import NmapUtil
from gym_pycr_pwcrack.envs.logic.cluster.util.exploit_util import ExploitUtil

class ExploitMiddleware:
    """
    Class that implements functionality for executing exploits actions on the cluster
    """

    @staticmethod
    def execute_telnet_same_user_dictionary(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a Telnet Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_ssh_same_user_dictionary(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a SSH Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_ftp_same_user_dictionary(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a FTP Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_cassandra_same_user_dictionary(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a Cassandra Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_irc_same_user_dictionary(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a IRC Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_mongo_same_user_dictionary(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a Mongo Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_mysql_same_user_dictionary(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a MySQL Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_smtp_same_user_dictionary(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a SMTP Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_postgres_same_user_dictionary(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a Postgres Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_sambacry(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a Sambacry Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.sambacry_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_shellshock(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a ShellShock Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.shellshock_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_dvwa_sql_injection(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a DVWA SQL Injection Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.dvwa_sql_injection_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_cve_2015_3306_exploit(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a CVE-2015-3306 Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.cve_2015_3306_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_cve_2015_1427_exploit(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a CVE-2015-1427 Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.cve_2015_1427_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_cve_2016_10033_exploit(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a CVE-2016-10033 Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.cve_2016_10033_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_cve_2010_0426_exploit(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a CVE-2010-0426 Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        print("2010-0426")
        #return s, 0, False
        new_machines_obs = []
        total_cost = 0
        total_alerts = (0, 0)
        for machine in s.obs_state.machines:
            m_cost = 0
            m_alerts = (0,0)
            cache_hit = False
            print("a.Ip:{}, mip:{}, logged in:{}, root:{}, backdoor:{}".format(a.ip, machine.ip, machine.logged_in, machine.root, machine.backdoor_installed))
            if a.ip == machine.ip and machine.logged_in and not machine.root and not machine.backdoor_installed:
                print("machine hit")
                new_m_obs = MachineObservationState(ip=machine.ip)
                usernames = ",".join(sorted(list(set(list(map(lambda x: x.username, machine.ssh_connections)) \
                                                     + list(map(lambda x: x.username, machine.telnet_connections)) \
                                                     + list(map(lambda x: x.username, machine.ftp_connections))))))
                key = (a.id, machine.ip, usernames)

                # Check in-memory cache
                if env_config.use_user_command_cache and env_config.user_command_cache.get(key) is not None:
                    print("in memory cache hit")
                    cache_hit = True
                    cache_obs, cost, exploit_successful = env_config.filesystem_scan_cache.get(key)
                    new_m_obs.root = cache_obs.root
                    new_m_obs.cve_2010_0426_tried = True
                    new_machines_obs.append(new_m_obs)
                    m_cost = cost
                    total_cost += m_cost
                    continue
                else:
                    print("checking cache on disk")
                    # Check on-disk cache
                    cache_file = ClusterUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                     user=env_config.cluster_config.agent_username)
                    if cache_file is not None:
                        cache_hit = True
                        cache_res = ClusterUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                        conn=env_config.cluster_config.agent_conn)
                        # Use measured cost
                        if env_config.action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                               user=env_config.cluster_config.agent_username,
                                                               service=constants.CVE_2010_0426.SERVICE_NAME):
                            a.cost = env_config.action_costs.find_get_cost(
                                action_id=a.id, ip=a.ip, user=env_config.cluster_config.agent_username,
                                service=constants.CVE_2010_0426.SERVICE_NAME)
                            m_cost = a.cost
                        cache_res_parts = cache_res.split(",")
                        cache_res_outcome = int(cache_res_parts[0])
                        cache_res_username = cache_res_parts[1]
                        cache_res_pw = cache_res_parts[2]
                        cache_res_service = cache_res_parts[3]
                        if cache_res_outcome == 0:
                            exploit_successful = False
                        else:
                            exploit_successful = True
                            if service == constants.SSH.SERVICE_NAME:
                                port = constants.SSH.DEFAULT_PORT
                            elif service == constants.FTP.SERVICE_NAME:
                                port = constants.FTP.DEFAULT_PORT
                            elif service == constants.TELNET.SERVICE_NAME:
                                port = constants.TELNET.DEFAULT_PORT
                            else:
                                raise ValueError("Service: {} not recognized".format(service))

                            proxy_conn = ConnectionObservationState(conn=env_config.cluster_config.agent_conn,
                                                                    username=env_config.cluster_config.agent_username,
                                                                    root=True, port=22,
                                                                    service=constants.SSH.SERVICE_NAME,
                                                                    proxy=None, ip=env_config.cluster_config.agent_ip)
                            cache_valid = ExploitUtil.check_if_rce_exploit_succeeded(
                                user=cache_res_username, pw=cache_res_pw, source_ip=env_config.cluster_config.agent_ip,
                                port=constants.SSH.DEFAULT_PORT, target_ip=a.ip, proxy_conn=proxy_conn)

                            if not cache_valid:
                                raise ValueError("Corrupted cache entry")

                            connection_dto = ClusterUtil.setup_custom_connection(
                                user=cache_res_username, pw=cache_res_pw, source_ip=env_config.cluster_config.agent_ip,
                                port=constants.SSH.DEFAULT_PORT, target_ip=a.ip, proxy_conn=proxy_conn, root=True)

                            credential = Credential(username=cache_res_username, pw=cache_res_pw,
                                                    port=port, protocol=TransportProtocol.TCP, service=service)
                            vuln = Vulnerability(
                                name=constants.EXPLOIT_VULNERABILITES.CVE_2010_0426,
                                cve=constants.EXPLOIT_VULNERABILITES.CVE_2010_0426, cvss=6,
                                credentials=[credential], port=port, protocol=TransportProtocol.TCP)
                            new_m_obs.cve_vulns.append(vuln)
                            new_m_obs.cve_2010_0426_tried = True
                            new_m_obs.shell_access_credentials.append(credential)
                            new_m_obs.backdoor_credentials.append(credential)
                            new_m_obs.backdoor_tried = True
                            new_m_obs.backdoor_installed = True
                            new_m_obs.shell_access = True
                            new_m_obs.logged_in = True
                            new_m_obs.ssh_connections.append(connection_dto)
                            exploit_successful = True

                if cache_hit:
                    print("cache hit")
                    # Use measured # alerts
                    if env_config.action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                               user=env_config.cluster_config.agent_username,
                                                               service=constants.CVE_2010_0426.SERVICE_NAME):
                        a.alerts = env_config.action_alerts.user_ip_get_alert(
                            action_id=a.id, ip=a.ip, user=env_config.cluster_config.agent_username,
                            service=constants.CVE_2010_0426.SERVICE_NAME)
                        m_alerts = (a.alerts[0], a.alerts[1])

                if not cache_hit:
                    print("cache miss")
                    # Try to escalate privileges using existing connections
                    new_m_obs, m_cost, m_alerts, exploit_successful, root_credential, service = \
                        ExploitUtil.cve_2010_0426_helper(s=s, a=a, env_config=env_config, machine=machine, result=new_m_obs)
                    new_machines_obs.append(new_m_obs)

                    if not exploit_successful:
                        username = "-"
                        pw = "-"
                        service = "-"
                    else:
                        username = root_credential.username
                        pw = root_credential.pw

                    # Persist cache result
                    cache_result = str(int(exploit_successful)) + "," + username + "," + pw \
                                   + "," + service
                    ClusterUtil.write_user_command_cache(action=a, env_config=env_config,
                                                         user=env_config.cluster_config.agent_username,
                                                         result=cache_result, ip=a.ip)

                    # Update cache
                    if env_config.use_user_command_cache:
                        env_config.user_command_cache.add(key, (new_m_obs, m_cost, exploit_successful))

                # Total cost update
                total_cost += m_cost

                # Total alerts update
                total_alerts = (total_alerts[0] + m_alerts[0], total_alerts[1] + m_alerts[1])

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root, total_new_osvdb_vuln_found, total_new_logged_in, \
        total_new_tools_installed, total_new_backdoors_installed = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, new_machines_obs, env_config=env_config,
                                                   action=a)
        s_prime = s
        s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_cve_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 num_new_osvdb_vuln_found=total_new_osvdb_vuln_found,
                                                 num_new_logged_in=total_new_logged_in,
                                                 num_new_tools_installed=total_new_tools_installed,
                                                 num_new_backdoors_installed=total_new_backdoors_installed,
                                                 cost=total_cost,
                                                 env_config=env_config,
                                                 alerts=total_alerts, action=a
                                                 )
        return s_prime, reward, False

    @staticmethod
    def execute_cve_2015_5602_exploit(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a CVE-2015-5602 Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        return s, 0, False
        # s_prime, reward, done = ExploitUtil.cve_2015_5602_helper(s=s, a=a, env_config=env_config)
        # return s_prime, reward, done
