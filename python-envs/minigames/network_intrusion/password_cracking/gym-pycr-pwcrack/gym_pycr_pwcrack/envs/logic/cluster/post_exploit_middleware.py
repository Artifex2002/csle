from typing import Tuple
import time
from gym_pycr_pwcrack.dao.network.env_state import EnvState
from gym_pycr_pwcrack.dao.network.env_config import EnvConfig
from gym_pycr_pwcrack.dao.action.action import Action
from gym_pycr_pwcrack.envs.logic.cluster.cluster_util import ClusterUtil
from gym_pycr_pwcrack.envs.logic.common.env_dynamics_util import EnvDynamicsUtil
import gym_pycr_pwcrack.constants.constants as constants
from gym_pycr_pwcrack.dao.observation.machine_observation_state import MachineObservationState

class PostExploitMiddleware:
    """
    Class that implements functionality for executing post-exploits actions on the cluster
    """

    @staticmethod
    def execute_ssh_login(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Executes a SSH login on the cluster

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ClusterUtil.login_service_helper(
            s=s, a=a, alive_check=EnvDynamicsUtil.check_if_ssh_connection_is_alive,
            service_name=constants.SSH.SERVICE_NAME, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_ftp_login(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Executes a FTP login on the server

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ClusterUtil.login_service_helper(
            s=s, a=a, alive_check=EnvDynamicsUtil.check_if_ftp_connection_is_alive,
            service_name=constants.FTP.SERVICE_NAME, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_telnet_login(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Executes a telnet login on the server

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ClusterUtil.login_service_helper(
            s=s, a=a, alive_check=EnvDynamicsUtil.check_if_telnet_connection_is_alive,
            service_name=constants.TELNET.SERVICE_NAME, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_bash_find_flag(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Searches the file system for all servers where the agent is currently logged in to find flags

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        new_machines_obs = []
        total_cost = 0
        for machine in s.obs_state.machines:
            if machine.logged_in:
                new_m_obs = MachineObservationState(ip=machine.ip)
                key = (machine.ip, machine.root)
                if env_config.use_file_system_cache and key in env_config.filesystem_scan_cache.cache:
                    new_m_obs, cost = env_config.filesystem_scan_cache.get(key)
                    new_machines_obs.append(new_m_obs)
                    total_cost = cost
                    continue

                flag_found = False
                root_scan = False
                # Start with ssh connections
                ssh_connections_sorted_by_root = sorted(machine.ssh_connections, key=lambda x: x.root, reverse=True)
                for c in ssh_connections_sorted_by_root:
                    cache_file = \
                        ClusterUtil.check_filesystem_action_cache(a=a, env_config=env_config, ip=machine.ip,
                                                                  service=constants.SSH.SERVICE_NAME,
                                                                  user=c.username)
                    if cache_file is not None:
                        flag_paths = ClusterUtil.parse_file_scan_file(file_name=cache_file,
                                                                      env_config=env_config)
                    else:
                        cmd = a.cmd[0]
                        if c.root:
                            cmd = constants.COMMANDS.SUDO + " " + cmd
                        outdata, errdata, total_time = ClusterUtil.execute_ssh_cmd(cmd=cmd, conn=c.conn)
                        ClusterUtil.write_estimated_cost(total_time=total_time, action=a,
                                                         env_config=env_config, ip=machine.ip,
                                                         user=c.username,
                                                         service=constants.SSH.SERVICE_NAME)
                        env_config.action_costs.find_add_cost(action_id=a.id, ip=machine.ip, user=c.username,
                                                              service=constants.SSH.SERVICE_NAME,
                                                              cost=float(total_time))
                        outdata_str = outdata.decode()
                        flag_paths = outdata_str.split("\n")
                        # Persist cache
                        ClusterUtil.write_file_system_scan_cache(action=a, env_config=env_config,
                                                                 service=constants.SSH.SERVICE_NAME, user=c.username,
                                                                 files=flag_paths, ip = machine.ip)

                    # Check for flags
                    for fp in flag_paths:
                        fp = fp.replace(".txt", "")
                        if (machine.ip, fp) in env_config.flag_lookup:
                            new_m_obs.flags_found.add(env_config.flag_lookup[(machine.ip, fp)])

                    # Update cost
                    if env_config.action_costs.find_exists(action_id=a.id, ip=machine.ip, user=c.username,
                                                           service=constants.SSH.SERVICE_NAME):
                        cost = env_config.action_costs.find_get_cost(action_id=a.id, ip=machine.ip, user=c.username,
                                                           service=constants.SSH.SERVICE_NAME)
                        total_cost += cost

                    if c.root:
                        root_scan = True
                        break

                if root_scan:
                    # Update cache
                    if env_config.use_file_system_cache:
                        env_config.filesystem_scan_cache.add(key, (new_m_obs, total_cost))
                    new_machines_obs.append(new_m_obs)
                    continue

                # If root scan not tried, try telnet connections
                telnet_connections_sorted_by_root = sorted(machine.telnet_connections, key=lambda x: x.root,
                                                           reverse=True)
                for c in telnet_connections_sorted_by_root:
                    cache_file = \
                        ClusterUtil.check_filesystem_action_cache(a=a, env_config=env_config, ip=machine.ip,
                                                                  service=constants.TELNET.SERVICE_NAME,
                                                                  user=c.username)
                    if cache_file is not None:
                        flag_paths = ClusterUtil.parse_file_scan_file(file_name=cache_file,
                                                                      env_config=env_config)
                    else:
                        cmd = a.cmd[0] + "\n"
                        if c.root:
                            cmd = constants.COMMANDS.SUDO + " " + cmd
                        start = time.time()
                        c.conn.write(cmd.encode())
                        response = c.conn.read_until(constants.TELNET.PROMPT, timeout=5)
                        end = time.time()
                        total_time = end - start
                        ClusterUtil.write_estimated_cost(total_time=total_time, action=a,
                                                         env_config=env_config, ip=machine.ip,
                                                         user=c.username,
                                                         service=constants.TELNET.SERVICE_NAME)
                        env_config.action_costs.find_add_cost(action_id=a.id, ip=machine.ip, user=c.username,
                                                              service=constants.TELNET.SERVICE_NAME,
                                                              cost=float(total_time))
                        flag_paths = response.decode().strip().split("\r\n")
                        # Persist cache
                        ClusterUtil.write_file_system_scan_cache(action=a, env_config=env_config,
                                                                 service=constants.TELNET.SERVICE_NAME, user=c.username,
                                                                 files=flag_paths, ip = machine.ip)

                    # Check for flags
                    for fp in flag_paths:
                        fp = fp.replace(".txt", "")
                        if (machine.ip, fp) in env_config.flag_lookup:
                            new_m_obs.flags_found.add(env_config.flag_lookup[(machine.ip, fp)])

                    # Update cost
                    if env_config.action_costs.find_exists(action_id=a.id, ip=machine.ip, user=c.username,
                                                           service=constants.TELNET.SERVICE_NAME):
                        cost = env_config.action_costs.find_get_cost(action_id=a.id, ip=machine.ip, user=c.username,
                                                                  service=constants.TELNET.SERVICE_NAME)
                        total_cost += cost

                    if c.root:
                        root_scan = True
                        break

                if root_scan:
                    # Update cache
                    if env_config.use_file_system_cache:
                        env_config.filesystem_scan_cache.add(key, (new_m_obs, total_cost))
                    new_machines_obs.append(new_m_obs)
                    continue

                # If root scan not tried, try ftp connections
                ftp_connections_sorted_by_root = sorted(machine.ftp_connections, key=lambda x: x.root, reverse=True)
                for c in ftp_connections_sorted_by_root:
                    cache_file = \
                        ClusterUtil.check_filesystem_action_cache(a=a, env_config=env_config, ip=machine.ip,
                                                                  service=constants.FTP.SERVICE_NAME,
                                                                  user=c.username)
                    if cache_file is not None:
                        flag_paths = ClusterUtil.parse_file_scan_file(file_name=cache_file,
                                                                      env_config=env_config)
                    else:
                        cmd = a.alt_cmd[0] + "\n"
                        if c.root:
                            cmd = constants.COMMANDS.SUDO + " " + cmd
                        start = time.time()
                        c.interactive_shell.send(cmd)
                        output = b""
                        # clear output
                        if c.interactive_shell.recv_ready():
                            c.interactive_shell.recv(constants.COMMON.DEFAULT_RECV_SIZE)
                        command_complete = False
                        timeouts = 0
                        while not command_complete:
                            while not c.interactive_shell.recv_ready():
                                if timeouts > env_config.shell_max_timeouts:
                                    break
                                time.sleep(env_config.shell_read_wait)
                                timeouts += 1
                            if c.interactive_shell.recv_ready():
                                output += c.interactive_shell.recv(constants.COMMON.LARGE_RECV_SIZE)
                                timeouts = 0
                                if constants.FTP.LFTP_PROMPT in output.decode() \
                                        or constants.FTP.LFTP_PROMPT_2 in output.decode():
                                    command_complete = True
                                    end = time.time()
                                    total_time = end - start
                                    ClusterUtil.write_estimated_cost(total_time=total_time, action=a,
                                                                     env_config=env_config, ip=machine.ip,
                                                                     user=c.username,
                                                                     service=constants.FTP.SERVICE_NAME)
                                    env_config.action_costs.find_add_cost(action_id=a.id, ip=machine.ip, user=c.username,
                                                                          service=constants.FTP.SERVICE_NAME,
                                                                          cost=float(total_time))
                            else:
                                break

                        output_str = output.decode("utf-8")
                        output_str = env_config.shell_escape.sub("", output_str)
                        output_list = output_str.split('\r\n')
                        output_list = output_list[1:-1]  # remove command ([0]) and prompt ([-1])
                        flag_paths = list(filter(lambda x: not constants.FTP.ACCESS_FAILED in x, output_list))

                        # Persist cache
                        ClusterUtil.write_file_system_scan_cache(action=a, env_config=env_config,
                                                                 service=constants.FTP.SERVICE_NAME, user=c.username,
                                                                 files = flag_paths, ip = machine.ip)
                    # Check for flags
                    for fp in flag_paths:
                        fp = fp.replace(".txt", "")
                        if (machine.ip, fp) in env_config.flag_lookup:
                            new_m_obs.flags_found.add(env_config.flag_lookup[(machine.ip, fp)])

                    # Update cost
                    if env_config.action_costs.find_exists(action_id=a.id, ip=machine.ip, user=c.username,
                                                           service=constants.FTP.SERVICE_NAME):
                        cost = env_config.action_costs.find_get_cost(action_id=a.id, ip=machine.ip, user=c.username,
                                                                  service=constants.FTP.SERVICE_NAME)
                        total_cost += cost

                # Update cache
                if env_config.use_file_system_cache:
                    env_config.filesystem_scan_cache.add(key, (new_m_obs, total_cost))

                new_machines_obs.append(new_m_obs)

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, new_machines_obs, env_config=env_config)
        s_prime = s
        s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 cost=total_cost,
                                                 env_config=env_config)

        done = EnvDynamicsUtil.is_all_flags_collected(s_prime, env_config)
        if done:
            reward = reward + env_config.all_flags_reward
        s_prime.obs_state.all_flags = done
        return s_prime, reward, done