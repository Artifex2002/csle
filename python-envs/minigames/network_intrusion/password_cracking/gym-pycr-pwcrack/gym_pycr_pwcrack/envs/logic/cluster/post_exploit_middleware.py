from typing import Union
import paramiko
from gym_pycr_pwcrack.dao.network.env_state import EnvState
from gym_pycr_pwcrack.dao.network.env_config import EnvConfig
from gym_pycr_pwcrack.dao.action.action import Action
from gym_pycr_pwcrack.envs.logic.cluster.cluster_util import ClusterUtil
from gym_pycr_pwcrack.envs.logic.common.env_dynamics_util import EnvDynamicsUtil
from gym_pycr_pwcrack.dao.observation.connection_observation_state import ConnectionObservationState

class PostExploitMiddleware:
    """
    Class that implements functionality for executing post-exploits actions on the cluster
    """

    @staticmethod
    def execute_ssh_login(s: EnvState, a: Action, env_config: EnvConfig) -> Union[EnvState, int, bool]:
        """
        Performs a Telnet Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        total_new_ports, total_new_os, total_new_vuln, total_new_machines, total_new_shell_access, \
        total_new_root, total_new_flag_pts = 0, 0, 0, 0, 0, 0, 0

        target_machine = None
        for m in s.obs_state.machines:
            if m.ip == a.ip:
                target_machine = m
                break
        if target_machine is not None:
            # Check if already logged in
            alive_connections = []
            root = False
            for c in target_machine.ssh_connections:
                if EnvDynamicsUtil.check_if_ssh_connection_is_alive(c.conn):
                    alive_connections.append(c)
                    if c.root:
                        root = c.root
            target_machine.root = root
            non_used_credentials = []
            root = False
            for cr in target_machine.shell_access_credentials:
                already_logged_in = False
                for c in alive_connections:
                    if not root and c.root:
                        root = True
                    if c.username == cr.username:
                        already_logged_in = True
                if not already_logged_in:
                    non_used_credentials.append(cr)
        if target_machine is None or root or len(non_used_credentials) == 0:
            reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                     num_new_vuln_found=total_new_vuln,
                                                     num_new_machines=total_new_machines,
                                                     num_new_shell_access=total_new_shell_access,
                                                     num_new_root=total_new_root,
                                                     num_new_flag_pts=total_new_flag_pts,
                                                     cost=a.cost)
            return s, reward, False


        # If not logged in and there are credentials, setup a new connection
        agent_addr = (env_config.cluster_config.agent_ip, 22)
        target_addr = (a.ip, 22)
        agent_transport = env_config.cluster_config.agent_conn.get_transport()
        relay_channel = agent_transport.open_channel("direct-tcpip", target_addr, agent_addr)
        target_conn = paramiko.SSHClient()
        target_conn.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        connected = False
        user = None
        for cr in target_machine.shell_access_credentials:
            if cr.service == "ssh":
                try:
                    target_conn.connect(a.ip, username=cr.username, password=cr.pw, sock=relay_channel)
                    connected = True
                    user = cr.username
                    break
                except:
                    pass
        s_prime = s
        if connected:
            target_machine.logged_in = True
            # Check if root
            outdata, errdata, total_time = ClusterUtil.execute_ssh_cmd(cmd="sudo -v", conn=target_conn)
            root = False
            if not "Sorry, user {} may not run sudo".format(user) in errdata.decode("utf-8"):
                root = True
                target_machine.root = True
            connection_dto = ConnectionObservationState(conn=target_conn, username=user, root=root, service="ssh")
            target_machine.ssh_connections.append(connection_dto)

            new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
            total_new_shell_access, total_new_flag_pts = \
                EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, [target_machine])
            s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 cost=a.cost)
        return s_prime, reward, False

    @staticmethod
    def execute_ftp_login(s: EnvState, a: Action, env_config: EnvConfig) -> Union[EnvState, int, bool]:
        """
        Performs a Telnet Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        pass

    @staticmethod
    def execute_telnet_login(s: EnvState, a: Action, env_config: EnvConfig) -> Union[EnvState, int, bool]:
        """
        Performs a Telnet Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        pass

    @staticmethod
    def execute_bash_find_flag(s: EnvState, a: Action, env_config: EnvConfig) -> Union[EnvState, int, bool]:
        """
        Performs a Telnet Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        pass