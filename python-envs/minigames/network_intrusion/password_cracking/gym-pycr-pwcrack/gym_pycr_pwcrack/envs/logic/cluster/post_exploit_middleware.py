from typing import Union
import paramiko
import telnetlib
from gym_pycr_pwcrack.dao.network.env_state import EnvState
from gym_pycr_pwcrack.dao.network.env_config import EnvConfig
from gym_pycr_pwcrack.dao.action.action import Action
from gym_pycr_pwcrack.envs.logic.cluster.cluster_util import ClusterUtil
from gym_pycr_pwcrack.envs.logic.common.env_dynamics_util import EnvDynamicsUtil
from gym_pycr_pwcrack.dao.observation.connection_observation_state import ConnectionObservationState
from gym_pycr_pwcrack.envs.logic.cluster.forward_tunnel_thread import ForwardTunnelThread
import gym_pycr_pwcrack.constants.constants as constants

class PostExploitMiddleware:
    """
    Class that implements functionality for executing post-exploits actions on the cluster
    """

    @staticmethod
    def execute_ssh_login(s: EnvState, a: Action, env_config: EnvConfig) -> Union[EnvState, int, bool]:
        """
        Executes a SSH login on the cluster

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        total_new_ports, total_new_os, total_new_vuln, total_new_machines, total_new_shell_access, \
        total_new_root, total_new_flag_pts = 0, 0, 0, 0, 0, 0, 0

        target_machine = None
        for m in s.obs_state.machines:
            if m.ip == a.ip:
                target_machine = m
                break
        if target_machine is not None:
            # Check if already logged in
            alive_connections = []
            root = False
            for c in target_machine.ssh_connections:
                if EnvDynamicsUtil.check_if_ssh_connection_is_alive(c.conn):
                    alive_connections.append(c)
                    if c.root:
                        root = c.root
            target_machine.root = root
            non_used_credentials = []
            root = False
            for cr in target_machine.shell_access_credentials:
                already_logged_in = False
                for c in alive_connections:
                    if not root and c.root:
                        root = True
                    if c.username == cr.username:
                        already_logged_in = True
                if not already_logged_in:
                    non_used_credentials.append(cr)
        if target_machine is None or root or len(non_used_credentials) == 0:
            reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                     num_new_vuln_found=total_new_vuln,
                                                     num_new_machines=total_new_machines,
                                                     num_new_shell_access=total_new_shell_access,
                                                     num_new_root=total_new_root,
                                                     num_new_flag_pts=total_new_flag_pts,
                                                     cost=a.cost)
            return s, reward, False


        # If not logged in and there are credentials, setup a new connection
        agent_addr = (env_config.cluster_config.agent_ip, 22)
        target_addr = (a.ip, 22)
        agent_transport = env_config.cluster_config.agent_conn.get_transport()
        relay_channel = agent_transport.open_channel("direct-tcpip", target_addr, agent_addr)
        connected = False
        users = []
        target_connections = []
        for cr in target_machine.shell_access_credentials:
            if cr.service == "ssh":
                try:
                    target_conn = paramiko.SSHClient()
                    target_conn.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    target_conn.connect(a.ip, username=cr.username, password=cr.pw, sock=relay_channel)
                    connected = True
                    users.append(cr.username)
                    target_connections.append(target_conn)
                except:
                    pass
        s_prime = s
        if connected:
            root = False
            target_machine.logged_in = True
            for i in range(len(target_connections)):
                # Check if root
                outdata, errdata, total_time = ClusterUtil.execute_ssh_cmd(cmd="sudo -v", conn=target_connections[i])
                root = False
                if not "Sorry, user {} may not run sudo".format(users[i]) in errdata.decode("utf-8"):
                    root = True
                    target_machine.root = True
                connection_dto = ConnectionObservationState(conn=target_connections[i], username=users[i], root=root,
                                                            service="ssh")
                target_machine.ssh_connections.append(connection_dto)

            target_machine.root = root
            new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
            total_new_shell_access, total_new_flag_pts = \
                EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, [target_machine])
            s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 cost=a.cost)
        return s_prime, reward, False

    @staticmethod
    def execute_ftp_login(s: EnvState, a: Action, env_config: EnvConfig) -> Union[EnvState, int, bool]:
        """
        Executes a FTP login on the server

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        return s, 0, False

    @staticmethod
    def execute_telnet_login(s: EnvState, a: Action, env_config: EnvConfig) -> Union[EnvState, int, bool]:
        """
        Executes a telnet login on the server

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        total_new_ports, total_new_os, total_new_vuln, total_new_machines, total_new_shell_access, \
        total_new_root, total_new_flag_pts = 0, 0, 0, 0, 0, 0, 0

        target_machine = None
        for m in s.obs_state.machines:
            if m.ip == a.ip:
                target_machine = m
                break
        if target_machine is not None:
            # Check if already logged in
            alive_connections = []
            root = False
            for c in target_machine.telnet_connections:
                if EnvDynamicsUtil.check_if_telnet_connection_is_alive(c.conn):
                    alive_connections.append(c)
                    if c.root:
                        root = c.root
            target_machine.root = root
            non_used_credentials = []
            root = False
            for cr in target_machine.shell_access_credentials:
                if cr.service == "telnet":
                    already_logged_in = False
                    for c in alive_connections:
                        if not root and c.root:
                            root = True
                        if c.username == cr.username:
                            already_logged_in = True
                    if not already_logged_in:
                        non_used_credentials.append(cr)

        if target_machine is None or root or len(non_used_credentials) == 0:
            reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                     num_new_vuln_found=total_new_vuln,
                                                     num_new_machines=total_new_machines,
                                                     num_new_shell_access=total_new_shell_access,
                                                     num_new_root=total_new_root,
                                                     num_new_flag_pts=total_new_flag_pts,
                                                     cost=a.cost)
            return s, reward, False

        # If not logged in and there are credentials, setup a new connection
        connected = False
        users = []
        target_connections = []
        tunnel_threads = []
        forward_ports = []
        for cr in target_machine.shell_access_credentials:
            if cr.service == "telnet":
                try:
                    forward_port = env_config.get_port_forward_port()
                    tunnel_thread = ForwardTunnelThread(local_port=forward_port,
                                                        remote_host=a.ip, remote_port=23,
                                                        transport=env_config.cluster_config.agent_conn.get_transport())
                    tunnel_thread.start()
                    target_conn = telnetlib.Telnet(host=constants.TELNET.LOCALHOST, port=forward_port)
                    target_conn.read_until(constants.TELNET.LOGIN_PROMPT, timeout=5)
                    target_conn.write((cr.username + "\n").encode())
                    target_conn.read_until(constants.TELNET.PASSWORD_PROMPT, timeout=5)
                    target_conn.write((cr.pw + "\n").encode())
                    response = target_conn.read_until(constants.TELNET.PROMPT, timeout=5)
                    if not constants.TELNET.INCORRECT_LOGIN in response.decode("utf-8"):
                        connected = True
                        users.append(cr.username)
                        target_connections.append(target_conn)
                        tunnel_threads.append(tunnel_thread)
                        forward_ports.append(forward_port)
                        break
                except Exception as e:
                    print("telnet exception:{}".format(str(e)))
                    pass
        s_prime = s
        if connected:
            root = False
            target_machine.logged_in = True
            for i in range(len(target_connections)):
                # Check if root
                target_connections[i].write("sudo -v\n".encode())
                response = target_connections[i].read_until(constants.TELNET.PROMPT, timeout=5)
                if not "Sorry, user {} may not run sudo".format(users[i]) in response.decode("utf-8"):
                    root = True
                connection_dto = ConnectionObservationState(conn=target_connections[i], username=users[i], root=root,
                                                            service="telnet", tunnel_thread=tunnel_threads[i],
                                                            tunnel_port=forward_ports[i])
                target_machine.telnet_connections.append(connection_dto)
            target_machine.root = root
            new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
            total_new_shell_access, total_new_flag_pts = \
                EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, [target_machine])
            s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 cost=a.cost)
        return s_prime, reward, False

    @staticmethod
    def execute_bash_find_flag(s: EnvState, a: Action, env_config: EnvConfig) -> Union[EnvState, int, bool]:
        """
        Performs a Telnet Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        return s, 0, False