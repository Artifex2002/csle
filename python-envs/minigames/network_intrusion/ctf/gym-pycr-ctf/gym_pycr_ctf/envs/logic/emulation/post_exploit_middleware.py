from typing import Tuple
from gym_pycr_ctf.dao.network.env_state import EnvState
from gym_pycr_ctf.dao.network.env_config import EnvConfig
from gym_pycr_ctf.dao.action.attacker.attacker_action import AttackerAction
from gym_pycr_ctf.envs.logic.common.env_dynamics_util import EnvDynamicsUtil
from gym_pycr_ctf.dao.observation.attacker.attacker_machine_observation_state import AttackerMachineObservationState
from gym_pycr_ctf.envs.logic.emulation.util.shell_util import ShellUtil

class PostExploitMiddleware:
    """
    Class that implements functionality for executing post-exploits actions on the emulation
    """

    @staticmethod
    def execute_service_login(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Executes a service login on the emulation using previously found credentials

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        return ShellUtil.execute_service_login_helper(s=s, a=a, env_config=env_config)

    @staticmethod
    def execute_bash_find_flag(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Searches the file system for all servers where the agent is currently logged in to find flags

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        new_machines_obs = []
        total_cost = 0
        total_alerts = (0,0)
        for machine in s.attacker_obs_state.machines:
            if machine.logged_in:
                new_m_obs = AttackerMachineObservationState(ip=machine.ip)
                key = (machine.ip, machine.root)
                if env_config.attacker_use_file_system_cache and env_config.attacker_filesystem_scan_cache.get(key) is not None:
                    cache_obs, cost = env_config.attacker_filesystem_scan_cache.get(key)
                    new_m_obs.flags_found = cache_obs.flags_found
                    new_m_obs.filesystem_searched = True
                    new_machines_obs.append(new_m_obs)
                    total_cost += cost
                    continue

                root_scan = False

                # Start with ssh connections
                new_m_obs, ssh_cost, ssh_root, ssh_alerts = ShellUtil._find_flag_using_ssh(
                    machine=machine, env_config=env_config, a=a, new_m_obs=new_m_obs)
                new_m_obs.filesystem_searched = True
                total_cost += ssh_cost
                total_alerts = (total_alerts[0] + ssh_alerts[0], total_alerts[1] + ssh_alerts[1])
                if ssh_root:
                    root_scan = True

                if root_scan:
                    # Update cache
                    if env_config.attacker_use_file_system_cache:
                        env_config.attacker_filesystem_scan_cache.add(key, (new_m_obs, total_cost))
                    new_machines_obs.append(new_m_obs)
                    continue

                # If root scan not tried, try telnet connections
                new_m_obs, telnet_cost, telnet_root, telnet_alerts = ShellUtil._find_flag_using_telnet(machine=machine, env_config=env_config,
                                                                             a=a, new_m_obs=new_m_obs)
                new_m_obs.filesystem_searched = True
                total_cost += telnet_cost
                total_alerts = (total_alerts[0] + telnet_alerts[0], total_alerts[1] + telnet_alerts[1])
                if telnet_root:
                    root_scan = True

                if root_scan:
                    # Update cache
                    if env_config.attacker_use_file_system_cache:
                        env_config.attacker_filesystem_scan_cache.add(key, (new_m_obs, total_cost))
                    new_machines_obs.append(new_m_obs)
                    continue

                # If root scan not tried, try ftp connections
                new_m_obs, ftp_cost, ftp_root, ftp_alerts = ShellUtil._find_flag_using_ftp(machine=machine, env_config=env_config,
                                                                       a=a, new_m_obs=new_m_obs)
                new_m_obs.filesystem_searched = True
                total_cost += ftp_cost
                total_alerts = (total_alerts[0] + ftp_alerts[0], total_alerts[1] + ftp_alerts[1])
                if ftp_root:
                    root_scan = True

                # Update cache
                if env_config.attacker_use_file_system_cache:
                    env_config.attacker_filesystem_scan_cache.add(key, (new_m_obs, total_cost))

                new_machines_obs.append(new_m_obs)

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root, total_new_osvdb_vuln_found, total_new_logged_in, \
        total_new_tools_installed, total_new_backdoors_installed = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, new_machines_obs, env_config=env_config,
                                                   action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_cve_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 num_new_osvdb_vuln_found=total_new_osvdb_vuln_found,
                                                 num_new_logged_in=total_new_logged_in,
                                                 num_new_tools_installed=total_new_tools_installed,
                                                 num_new_backdoors_installed=total_new_backdoors_installed,
                                                 cost=total_cost,
                                                 env_config=env_config,
                                                 alerts = total_alerts, action=a
                                                 )
        s_prime.attacker_obs_state.catched_flags += total_new_flag_pts
        done = EnvDynamicsUtil.is_all_flags_collected(s_prime, env_config)
        if done:
            reward = reward + env_config.attacker_all_flags_reward
        s_prime.attacker_obs_state.all_flags = done
        return s_prime, reward, done

    @staticmethod
    def execute_install_tools(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Uses compromised machines with root access to install tools

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        return ShellUtil.install_tools_helper(s=s, a=a, env_config=env_config)

    @staticmethod
    def execute_ssh_backdoor(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Uses compromised machines with root access to setup SSH backdoor

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        return ShellUtil.execute_ssh_backdoor_helper(s=s, a=a, env_config=env_config)
