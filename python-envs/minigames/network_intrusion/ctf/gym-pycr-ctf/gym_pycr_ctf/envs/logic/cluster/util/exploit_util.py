from typing import Tuple
import time
import paramiko
import sys
from gym_pycr_ctf.dao.network.env_config import EnvConfig
from gym_pycr_ctf.dao.action.action import Action
from gym_pycr_ctf.dao.network.env_state import EnvState
from gym_pycr_ctf.dao.network.transport_protocol import TransportProtocol
from gym_pycr_ctf.envs.logic.common.env_dynamics_util import EnvDynamicsUtil
import gym_pycr_ctf.constants.constants as constants
from gym_pycr_ctf.dao.observation.connection_observation_state import ConnectionObservationState
from gym_pycr_ctf.dao.observation.machine_observation_state import MachineObservationState
from gym_pycr_ctf.dao.network.credential import Credential
from gym_pycr_ctf.dao.network.vulnerability import Vulnerability
from gym_pycr_ctf.envs.logic.cluster.util.cluster_util import ClusterUtil
from gym_pycr_ctf.envs.logic.cluster.util.connection_util import ConnectionUtil

class ExploitUtil:
    """
    Class containing utility functions for the exploit-related functionality to the Cluster
    """

    @staticmethod
    def sambacry_helper(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Helper for executing the SambaCry exploit action

        :param s: the current state
        :param a: the SambaCry exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = None
        for m in s.obs_state.machines:
            if m.ip == a.ip:
                target_machine = m.copy()
        if target_machine is None:
            target_machine = MachineObservationState(ip=a.ip)

        jump_connection = ConnectionUtil.find_jump_host_connection(ip=target_machine.ip, s=s, env_config=env_config)
        base_cache_id = (a.id, a.index, a.ip, a.subnet, jump_connection.username)
        cache_key = base_cache_id
        exploit_successful = False

        # Check cache first
        cache_hit = False
        if env_config.use_user_command_cache:

            # Check in-memory cache
            if env_config.user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful = env_config.user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = ClusterUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                 user=jump_connection.username,
                                                                 jumphost=jump_connection.ip)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = ClusterUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                    conn=env_config.cluster_config.agent_conn)
                    # Use measured cost
                    if env_config.action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                           user=constants.SAMBA.BACKDOOR_USER,
                                                           service=constants.SAMBA.SERVICE_NAME):
                        a.cost = env_config.action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=constants.SAMBA.BACKDOOR_USER,
                            service=constants.SAMBA.SERVICE_NAME)
                        cost = a.cost
                    else:
                        cost = 0

                    if int(cache_res) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.SAMBA.BACKDOOR_USER, pw=constants.SAMBA.BACKDOOR_PW,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = Vulnerability(
                            name=constants.EXPLOIT_VULNERABILITES.SAMBACRY_EXPLOIT,
                            cve=constants.EXPLOIT_VULNERABILITES.SAMBACRY_EXPLOIT, cvss=9.8,
                            credentials=[Credential(username=constants.SAMBA.USER, pw=constants.SAMBA.PW,
                                                    service=constants.SAMBA.SERVICE_NAME)
                                         ], port=constants.SAMBA.PORT, protocol=TransportProtocol.TCP)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                           user=constants.SAMBA.BACKDOOR_USER,
                                                           service=constants.SAMBA.SERVICE_NAME):
                    a.alerts = env_config.action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                          user=constants.SAMBA.BACKDOOR_USER,
                                                                          service=constants.SAMBA.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:
            # Try execute exploit from jumphost
            cost = 0
            total_alerts = (0, 0)
            if env_config.ids_router:
                last_alert_ts = ClusterUtil.get_latest_alert_ts(env_config=env_config)
            cmd = a.cmd[0]
            cmd = cmd.format(a.ip)
            outdata, errdata, total_time = ClusterUtil.execute_ssh_cmd(
                cmd=cmd, conn=jump_connection.conn)

            # Parse Result
            if constants.SAMBA.ALREADY_EXISTS in outdata.decode() or (constants.SAMBA.ERROR not in outdata.decode()
                                                                      and constants.SAMBA.ERROR not in errdata.decode()):
                # Exploit successful
                credential = Credential(username=constants.SAMBA.BACKDOOR_USER, pw=constants.SAMBA.BACKDOOR_PW,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = Vulnerability(
                    name=constants.EXPLOIT_VULNERABILITES.SAMBACRY_EXPLOIT,
                    cve=constants.EXPLOIT_VULNERABILITES.SAMBACRY_EXPLOIT, cvss=9.8,
                    credentials=[Credential(username=constants.SAMBA.USER, pw=constants.SAMBA.PW,
                                            service=constants.SAMBA.SERVICE_NAME)
                                 ], port=constants.SAMBA.PORT, protocol=TransportProtocol.TCP)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)
                exploit_successful = True
            else:
                exploit_successful = False

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = ClusterUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                ClusterUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                  action=a, env_config=env_config,
                                                  user=constants.SAMBA.BACKDOOR_USER,
                                                  service=constants.SAMBA.SERVICE_NAME,
                                                  conn=env_config.cluster_config.agent_conn)
                env_config.action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                           alert=(sum_priority_alerts, num_alerts),
                                                           user=constants.SAMBA.BACKDOOR_USER,
                                                           service=constants.SAMBA.SERVICE_NAME)

            ClusterUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                             user=constants.SAMBA.BACKDOOR_USER,
                                             service=constants.SAMBA.SERVICE_NAME,
                                             conn=env_config.cluster_config.agent_conn)
            env_config.action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                  user=constants.SAMBA.BACKDOOR_USER,
                                                  service=constants.SAMBA.SERVICE_NAME)

            # Persist cache result
            ClusterUtil.write_user_command_cache(action=a, env_config=env_config,
                                                 user=jump_connection.username,
                                                 result=str(int(exploit_successful)), ip=a.ip,
                                                 jumphost=jump_connection.ip)

            # Update cache
            if env_config.use_user_command_cache:
                env_config.user_command_cache.add(cache_key, (target_machine, cost, exploit_successful))

        target_machine.sambacry_tried = True

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root, total_new_osvdb_vuln_found, total_new_logged_in, \
        total_new_tools_installed, total_new_backdoors_installed = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, [target_machine], env_config=env_config,
                                                   action=a)
        s_prime = s
        s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_cve_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 num_new_osvdb_vuln_found=total_new_osvdb_vuln_found,
                                                 num_new_logged_in=total_new_logged_in,
                                                 num_new_tools_installed=total_new_tools_installed,
                                                 num_new_backdoors_installed=total_new_backdoors_installed,
                                                 cost=cost,
                                                 env_config=env_config,
                                                 alerts=total_alerts, action=a)
        return s, reward, False

    @staticmethod
    def shellshock_helper(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Helper for executing the ShellShock exploit action

        :param s: the current state
        :param a: the Shellshock exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = None
        for m in s.obs_state.machines:
            if m.ip == a.ip:
                target_machine = m.copy()
        if target_machine is None:
            target_machine = MachineObservationState(ip=a.ip)

        cache_key = (a.id, target_machine.ip, env_config.cluster_config.agent_username)
        exploit_successful = False

        # Check cache first
        cache_hit = False
        if env_config.use_user_command_cache:

            # Check in-memory cache
            if env_config.user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful = env_config.user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = ClusterUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                 user=env_config.cluster_config.agent_username)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = ClusterUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                    conn=env_config.cluster_config.agent_conn)
                    # Use measured cost
                    if env_config.action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.SHELLSHOCK.SERVICE_NAME):
                        a.cost = env_config.action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=env_config.cluster_config.agent_username,
                            service=constants.SHELLSHOCK.SERVICE_NAME)
                        cost = a.cost

                    if int(cache_res) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.SHELLSHOCK.BACKDOOR_USER,
                                                pw=constants.SHELLSHOCK.BACKDOOR_PW,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = Vulnerability(
                            name=constants.EXPLOIT_VULNERABILITES.SHELLSHOCK_EXPLOIT,
                            cve=constants.EXPLOIT_VULNERABILITES.SHELLSHOCK_EXPLOIT, cvss=9.8,
                            credentials=[Credential(username=constants.SHELLSHOCK.BACKDOOR_USER,
                                                    pw=constants.SHELLSHOCK.BACKDOOR_PW,
                                                    service=constants.SHELLSHOCK.SERVICE_NAME)
                                         ], port=constants.SHELLSHOCK.PORT, protocol=TransportProtocol.TCP)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.SHELLSHOCK.SERVICE_NAME):
                    a.alerts = env_config.action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                          user=env_config.cluster_config.agent_username,
                                                                          service=constants.SHELLSHOCK.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:
            # Try execute exploit from agent host
            cost = 0
            total_alerts = (0, 0)
            if env_config.ids_router:
                last_alert_ts = ClusterUtil.get_latest_alert_ts(env_config=env_config)
            cmd = a.cmd[0]
            cmd = cmd.format(constants.SHELLSHOCK.BACKDOOR_USER, constants.SHELLSHOCK.BACKDOOR_PW,
                             constants.SHELLSHOCK.BACKDOOR_USER, a.ip)
            outdata, errdata, total_time = ClusterUtil.execute_ssh_cmd(
                cmd=cmd, conn=env_config.cluster_config.agent_conn)

            cmd = a.cmd[1]
            cmd = cmd.format(constants.SHELLSHOCK.BACKDOOR_USER, constants.SHELLSHOCK.BACKDOOR_PW, a.ip)
            outdata1, errdata1, total_time1 = ClusterUtil.execute_ssh_cmd(
                cmd=cmd, conn=env_config.cluster_config.agent_conn)
            total_time = total_time + total_time1

            # Parse Result
            proxy_conn = ConnectionObservationState(conn=env_config.cluster_config.agent_conn,
                                                    username=env_config.cluster_config.agent_username,
                                                    root=True, port=22, service=constants.SSH.SERVICE_NAME,
                                                    proxy=None, ip=env_config.cluster_config.agent_ip)
            if ExploitUtil.check_if_rce_exploit_succeeded(user=constants.SHELLSHOCK.BACKDOOR_USER,
                                                          pw=constants.SHELLSHOCK.BACKDOOR_PW,
                                                          source_ip=env_config.cluster_config.agent_ip,
                                                          port=constants.SSH.DEFAULT_PORT,
                                                          target_ip=a.ip,
                                                          proxy_conn=proxy_conn):
                # Exploit successful
                credential = Credential(username=constants.SHELLSHOCK.BACKDOOR_USER,
                                        pw=constants.SHELLSHOCK.BACKDOOR_PW,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = Vulnerability(
                    name=constants.EXPLOIT_VULNERABILITES.SHELLSHOCK_EXPLOIT,
                    cve=constants.EXPLOIT_VULNERABILITES.SHELLSHOCK_EXPLOIT, cvss=9.8,
                    credentials=[Credential(username=constants.SHELLSHOCK.BACKDOOR_USER,
                                            pw=constants.SHELLSHOCK.BACKDOOR_PW,
                                            service=constants.SHELLSHOCK.SERVICE_NAME)
                                 ], port=constants.SHELLSHOCK.PORT, protocol=TransportProtocol.TCP)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)
                exploit_successful = True

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = ClusterUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                ClusterUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                  action=a, env_config=env_config,
                                                  user=env_config.cluster_config.agent_username,
                                                  service=constants.SHELLSHOCK.SERVICE_NAME)
                env_config.action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                           alert=(sum_priority_alerts, num_alerts),
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.SHELLSHOCK.SERVICE_NAME)

            ClusterUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                             user=env_config.cluster_config.agent_username,
                                             service=constants.SHELLSHOCK.SERVICE_NAME)
            env_config.action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                  user=env_config.cluster_config.agent_username,
                                                  service=constants.SHELLSHOCK.SERVICE_NAME)

            # Persist cache result
            ClusterUtil.write_user_command_cache(action=a, env_config=env_config,
                                                 user=env_config.cluster_config.agent_username,
                                                 result=str(int(exploit_successful)), ip=a.ip)

            # Update cache
            if env_config.use_user_command_cache:
                env_config.user_command_cache.add(cache_key, (target_machine, cost, exploit_successful))

        target_machine.shellshock_tried = True

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root, total_new_osvdb_vuln_found, total_new_logged_in, \
        total_new_tools_installed, total_new_backdoors_installed = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, [target_machine], env_config=env_config,
                                                   action=a)
        s_prime = s
        s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_cve_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 num_new_osvdb_vuln_found=total_new_osvdb_vuln_found,
                                                 num_new_logged_in=total_new_logged_in,
                                                 num_new_tools_installed=total_new_tools_installed,
                                                 num_new_backdoors_installed=total_new_backdoors_installed,
                                                 cost=cost,
                                                 env_config=env_config,
                                                 alerts=total_alerts, action=a)
        return s, reward, False

    @staticmethod
    def check_if_rce_exploit_succeeded(user: str, pw: str, source_ip: str, port: int, target_ip: str,
                                       proxy_conn) -> bool:
        agent_addr = (source_ip, port)
        target_addr = (target_ip, port)
        agent_transport = proxy_conn.conn.get_transport()
        try:
            relay_channel = agent_transport.open_channel(constants.SSH.DIRECT_CHANNEL, target_addr, agent_addr,
                                                         timeout=3)
            target_conn = paramiko.SSHClient()
            target_conn.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            target_conn.connect(target_ip, username=user, password=pw, sock=relay_channel,
                                timeout=3)
            return True
        except Exception as e:
            print("Shellshock error:{}".format(str(e)))
            return False

    @staticmethod
    def dvwa_sql_injection_helper(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Helper for executing the DVWA SQL Injection exploit action

        :param s: the current state
        :param a: the DVWA SQL Injection exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = None
        for m in s.obs_state.machines:
            if m.ip == a.ip:
                target_machine = m.copy()
        if target_machine is None:
            target_machine = MachineObservationState(ip=a.ip)

        cache_key = (a.id, target_machine.ip, env_config.cluster_config.agent_username)
        exploit_successful = False

        # Check cache first
        cache_hit = False
        if env_config.use_user_command_cache:

            # Check in-memory cache
            if env_config.user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful, pw = env_config.user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = ClusterUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                 user=env_config.cluster_config.agent_username)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = ClusterUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                    conn=env_config.cluster_config.agent_conn)
                    cache_res_parts = cache_res.split(",")
                    cache_res_outcome = cache_res_parts[0]
                    cache_res_pw = cache_res_parts[1]
                    # Use measured cost
                    if env_config.action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.DVWA_SQL_INJECTION.SERVICE_NAME):
                        a.cost = env_config.action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=env_config.cluster_config.agent_username,
                            service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
                        cost = a.cost

                    if int(cache_res_outcome) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.DVWA_SQL_INJECTION.EXPLOIT_USER,
                                                pw=cache_res_pw,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = Vulnerability(
                            name=constants.EXPLOIT_VULNERABILITES.DVWA_SQL_INJECTION,
                            cve=None, cvss=9.8,
                            credentials=[Credential(username=constants.DVWA_SQL_INJECTION.EXPLOIT_USER,
                                                    pw=cache_res_pw,
                                                    service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
                                         ], port=constants.DVWA_SQL_INJECTION.PORT, protocol=TransportProtocol.TCP)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.DVWA_SQL_INJECTION.SERVICE_NAME):
                    a.alerts = env_config.action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                          user=env_config.cluster_config.agent_username,
                                                                          service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:
            # Try execute exploit from agent host
            cost = 0
            total_alerts = (0, 0)
            if env_config.ids_router:
                last_alert_ts = ClusterUtil.get_latest_alert_ts(env_config=env_config)
            cmd = a.cmd[0]
            cmd = cmd + " " + a.ip
            outdata, errdata, total_time = ClusterUtil.execute_ssh_cmd(
                cmd=cmd, conn=env_config.cluster_config.agent_conn)
            # Parse Result
            exploit_successful = False
            try:
                exploit_result = ExploitUtil.read_dvwa_sql_injection_result(conn=env_config.cluster_config.agent_conn,
                                                                            env_config=env_config)
                pw = exploit_result[
                     exploit_result.find("pablo:") + 6: exploit_result.find("pablo:") + 6 + exploit_result[
                                                                                            exploit_result.find(
                                                                                                "pablo:") + 6:].find(
                         "<")]
                if "0d107" in pw:
                    exploit_successful = True
                else:
                    exploit_successful = False
                    pw = "-"
            except Exception as e:
                exploit_successful = False
                pw = "-"
            if exploit_successful:
                ExploitUtil.remove_dvwa_sql_injection_result(conn=env_config.cluster_config.agent_conn,
                                                             env_config=env_config)
                # Exploit successful
                credential = Credential(username=constants.DVWA_SQL_INJECTION.EXPLOIT_USER,
                                        pw=pw,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = Vulnerability(
                    name=constants.EXPLOIT_VULNERABILITES.DVWA_SQL_INJECTION,
                    cve=None, cvss=9.8,
                    credentials=[Credential(username=constants.DVWA_SQL_INJECTION.EXPLOIT_USER,
                                            pw=pw,
                                            service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
                                 ], port=constants.DVWA_SQL_INJECTION.PORT, protocol=TransportProtocol.TCP)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)
                exploit_successful = True

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = ClusterUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                ClusterUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                  action=a, env_config=env_config,
                                                  user=env_config.cluster_config.agent_username,
                                                  service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
                env_config.action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                           alert=(sum_priority_alerts, num_alerts),
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)

            ClusterUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                             user=env_config.cluster_config.agent_username,
                                             service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)
            env_config.action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                  user=env_config.cluster_config.agent_username,
                                                  service=constants.DVWA_SQL_INJECTION.SERVICE_NAME)

            # Persist cache result
            ClusterUtil.write_user_command_cache(action=a, env_config=env_config,
                                                 user=env_config.cluster_config.agent_username,
                                                 result=str(int(exploit_successful)) + "," + pw, ip=a.ip)

            # Update cache
            if env_config.use_user_command_cache:
                env_config.user_command_cache.add(cache_key, (target_machine, cost, exploit_successful, pw))

        target_machine.dvwa_sql_injection_tried = True

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root, total_new_osvdb_vuln_found, total_new_logged_in, \
        total_new_tools_installed, total_new_backdoors_installed = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, [target_machine], env_config=env_config,
                                                   action=a)
        s_prime = s
        s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_cve_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 num_new_osvdb_vuln_found=total_new_osvdb_vuln_found,
                                                 num_new_logged_in=total_new_logged_in,
                                                 num_new_tools_installed=total_new_tools_installed,
                                                 num_new_backdoors_installed=total_new_backdoors_installed,
                                                 cost=cost,
                                                 env_config=env_config,
                                                 alerts=total_alerts, action=a)
        return s, reward, False

    @staticmethod
    def read_dvwa_sql_injection_result(conn, env_config: EnvConfig) -> str:
        """
        Reads the result of a DVWA SQL Injection Attack
        :param conn: connection to use for reading
        :param env_config: environment config
        :return: the read result
        """
        sftp_client = conn.open_sftp()
        remote_file = sftp_client.open(env_config.nmap_cache_dir + constants.DVWA_SQL_INJECTION.EXPLOIT_OUTPUT_FILENAME)
        result = None
        try:
            data = remote_file.read()
            result = data.decode()
        finally:
            remote_file.close()
        return result

    @staticmethod
    def remove_dvwa_sql_injection_result(conn, env_config: EnvConfig) -> None:
        """
        Remove the result of a DVWA SQL Injection Attack
        :param conn: connection to use for the removal
        :param env_config: environment config
        :return: None
        """
        sftp_client = conn.open_sftp()
        sftp_client.remove(env_config.nmap_cache_dir + constants.DVWA_SQL_INJECTION.EXPLOIT_OUTPUT_FILENAME)

    @staticmethod
    def cve_2015_3306_helper(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Helper for executing the CVE-2015-3306 exploit action

        :param s: the current state
        :param a: the CVE-2015-3306 exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = None
        for m in s.obs_state.machines:
            if m.ip == a.ip:
                target_machine = m.copy()
        if target_machine is None:
            target_machine = MachineObservationState(ip=a.ip)

        cache_key = (a.id, target_machine.ip, env_config.cluster_config.agent_username)
        exploit_successful = False

        # Check cache first
        cache_hit = False
        if env_config.use_user_command_cache:

            # Check in-memory cache
            if env_config.user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful = env_config.user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = ClusterUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                 user=env_config.cluster_config.agent_username)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = ClusterUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                    conn=env_config.cluster_config.agent_conn)
                    # Use measured cost
                    if env_config.action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.CVE_2015_3306.SERVICE_NAME):
                        a.cost = env_config.action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=env_config.cluster_config.agent_username,
                            service=constants.CVE_2015_3306.SERVICE_NAME)
                        cost = a.cost

                    if int(cache_res) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.CVE_2015_3306.BACKDOOR_USER,
                                                pw=constants.CVE_2015_3306.BACKDOOR_PW,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = Vulnerability(
                            name=constants.EXPLOIT_VULNERABILITES.CVE_2015_3306,
                            cve=constants.EXPLOIT_VULNERABILITES.CVE_2015_3306, cvss=9.8,
                            credentials=[Credential(username=constants.CVE_2015_3306.BACKDOOR_USER,
                                                    pw=constants.CVE_2015_3306.BACKDOOR_PW,
                                                    service=constants.CVE_2015_3306.SERVICE_NAME)
                                         ], port=constants.CVE_2015_3306.PORT, protocol=TransportProtocol.TCP)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.CVE_2015_3306.SERVICE_NAME):
                    a.alerts = env_config.action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                          user=env_config.cluster_config.agent_username,
                                                                          service=constants.CVE_2015_3306.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:
            # Try execute exploit from agent host
            cost = 0
            total_alerts = (0, 0)
            if env_config.ids_router:
                last_alert_ts = ClusterUtil.get_latest_alert_ts(env_config=env_config)
            cmd = a.cmd[0]
            cmd = cmd.format(a.ip)
            outdata, errdata, total_time = ClusterUtil.execute_ssh_cmd(
                cmd=cmd, conn=env_config.cluster_config.agent_conn)

            # Parse Result
            proxy_conn = ConnectionObservationState(conn=env_config.cluster_config.agent_conn,
                                                    username=env_config.cluster_config.agent_username,
                                                    root=True, port=22, service=constants.SSH.SERVICE_NAME,
                                                    proxy=None, ip=env_config.cluster_config.agent_ip)
            if ExploitUtil.check_if_rce_exploit_succeeded(user=constants.CVE_2015_3306.BACKDOOR_USER,
                                                          pw=constants.CVE_2015_3306.BACKDOOR_PW,
                                                          source_ip=env_config.cluster_config.agent_ip,
                                                          port=constants.SSH.DEFAULT_PORT,
                                                          target_ip=a.ip,
                                                          proxy_conn=proxy_conn):
                # Exploit successful
                credential = Credential(username=constants.CVE_2015_3306.BACKDOOR_USER,
                                        pw=constants.CVE_2015_3306.BACKDOOR_PW,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = Vulnerability(
                    name=constants.EXPLOIT_VULNERABILITES.CVE_2015_3306,
                    cve=constants.EXPLOIT_VULNERABILITES.CVE_2015_3306, cvss=9.8,
                    credentials=[Credential(username=constants.CVE_2015_3306.BACKDOOR_USER,
                                            pw=constants.CVE_2015_3306.BACKDOOR_PW,
                                            service=constants.CVE_2015_3306.SERVICE_NAME)
                                 ], port=constants.CVE_2015_3306.PORT, protocol=TransportProtocol.TCP)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)
                exploit_successful = True

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = ClusterUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                ClusterUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                  action=a, env_config=env_config,
                                                  user=env_config.cluster_config.agent_username,
                                                  service=constants.CVE_2015_3306.SERVICE_NAME)
                env_config.action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                           alert=(sum_priority_alerts, num_alerts),
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.CVE_2015_3306.SERVICE_NAME)

            ClusterUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                             user=env_config.cluster_config.agent_username,
                                             service=constants.CVE_2015_3306.SERVICE_NAME)
            env_config.action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                  user=env_config.cluster_config.agent_username,
                                                  service=constants.CVE_2015_3306.SERVICE_NAME)

            # Persist cache result
            ClusterUtil.write_user_command_cache(action=a, env_config=env_config,
                                                 user=env_config.cluster_config.agent_username,
                                                 result=str(int(exploit_successful)), ip=a.ip)

            # Update cache
            if env_config.use_user_command_cache:
                env_config.user_command_cache.add(cache_key, (target_machine, cost, exploit_successful))

        target_machine.cve_2015_3306_tried = True

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root, total_new_osvdb_vuln_found, total_new_logged_in, \
        total_new_tools_installed, total_new_backdoors_installed = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, [target_machine], env_config=env_config,
                                                   action=a)
        s_prime = s
        s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_cve_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 num_new_osvdb_vuln_found=total_new_osvdb_vuln_found,
                                                 num_new_logged_in=total_new_logged_in,
                                                 num_new_tools_installed=total_new_tools_installed,
                                                 num_new_backdoors_installed=total_new_backdoors_installed,
                                                 cost=cost,
                                                 env_config=env_config,
                                                 alerts=total_alerts, action=a)
        return s, reward, False

    @staticmethod
    def cve_2015_1427_helper(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Helper for executing the CVE-2015-1427 exploit action

        :param s: the current state
        :param a: the CVE-2015-1427 exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = None
        for m in s.obs_state.machines:
            if m.ip == a.ip:
                target_machine = m.copy()
        if target_machine is None:
            target_machine = MachineObservationState(ip=a.ip)

        cache_key = (a.id, target_machine.ip, env_config.cluster_config.agent_username)
        exploit_successful = False

        # Check cache first
        cache_hit = False
        if env_config.use_user_command_cache:

            # Check in-memory cache
            if env_config.user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful = env_config.user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = ClusterUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                 user=env_config.cluster_config.agent_username)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = ClusterUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                    conn=env_config.cluster_config.agent_conn)
                    # Use measured cost
                    if env_config.action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.CVE_2015_1427.SERVICE_NAME):
                        a.cost = env_config.action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=env_config.cluster_config.agent_username,
                            service=constants.CVE_2015_1427.SERVICE_NAME)
                        cost = a.cost

                    if int(cache_res) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.CVE_2015_1427.BACKDOOR_USER,
                                                pw=constants.CVE_2015_1427.BACKDOOR_PW,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = Vulnerability(
                            name=constants.EXPLOIT_VULNERABILITES.CVE_2015_1427,
                            cve=constants.EXPLOIT_VULNERABILITES.CVE_2015_1427, cvss=9.8,
                            credentials=[Credential(username=constants.CVE_2015_1427.BACKDOOR_USER,
                                                    pw=constants.CVE_2015_1427.BACKDOOR_PW,
                                                    service=constants.CVE_2015_1427.SERVICE_NAME)
                                         ], port=constants.CVE_2015_1427.PORT, protocol=TransportProtocol.TCP)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.CVE_2015_1427.SERVICE_NAME):
                    a.alerts = env_config.action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                          user=env_config.cluster_config.agent_username,
                                                                          service=constants.CVE_2015_1427.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:
            # Try execute exploit from agent host
            cost = 0
            total_alerts = (0, 0)
            if env_config.ids_router:
                last_alert_ts = ClusterUtil.get_latest_alert_ts(env_config=env_config)
            cmd = a.cmd[0]
            cmd = cmd.format(a.ip)
            outdata, errdata, total_time = ClusterUtil.execute_ssh_cmd(
                cmd=cmd, conn=env_config.cluster_config.agent_conn)

            # Parse Result
            proxy_conn = ConnectionObservationState(conn=env_config.cluster_config.agent_conn,
                                                    username=env_config.cluster_config.agent_username,
                                                    root=True, port=22, service=constants.SSH.SERVICE_NAME,
                                                    proxy=None, ip=env_config.cluster_config.agent_ip)
            if ExploitUtil.check_if_rce_exploit_succeeded(user=constants.CVE_2015_1427.BACKDOOR_USER,
                                                          pw=constants.CVE_2015_1427.BACKDOOR_PW,
                                                          source_ip=env_config.cluster_config.agent_ip,
                                                          port=constants.SSH.DEFAULT_PORT,
                                                          target_ip=a.ip,
                                                          proxy_conn=proxy_conn):
                # Exploit successful
                credential = Credential(username=constants.CVE_2015_1427.BACKDOOR_USER,
                                        pw=constants.CVE_2015_1427.BACKDOOR_PW,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = Vulnerability(
                    name=constants.EXPLOIT_VULNERABILITES.CVE_2015_1427,
                    cve=constants.EXPLOIT_VULNERABILITES.CVE_2015_1427, cvss=9.8,
                    credentials=[Credential(username=constants.CVE_2015_1427.BACKDOOR_USER,
                                            pw=constants.CVE_2015_1427.BACKDOOR_PW,
                                            service=constants.CVE_2015_1427.SERVICE_NAME)
                                 ], port=constants.CVE_2015_1427.PORT, protocol=TransportProtocol.TCP)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)
                exploit_successful = True

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = ClusterUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                ClusterUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                  action=a, env_config=env_config,
                                                  user=env_config.cluster_config.agent_username,
                                                  service=constants.CVE_2015_1427.SERVICE_NAME)
                env_config.action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                           alert=(sum_priority_alerts, num_alerts),
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.CVE_2015_1427.SERVICE_NAME)

            ClusterUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                             user=env_config.cluster_config.agent_username,
                                             service=constants.CVE_2015_1427.SERVICE_NAME)
            env_config.action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                  user=env_config.cluster_config.agent_username,
                                                  service=constants.CVE_2015_1427.SERVICE_NAME)

            # Persist cache result
            ClusterUtil.write_user_command_cache(action=a, env_config=env_config,
                                                 user=env_config.cluster_config.agent_username,
                                                 result=str(int(exploit_successful)), ip=a.ip)

            # Update cache
            if env_config.use_user_command_cache:
                env_config.user_command_cache.add(cache_key, (target_machine, cost, exploit_successful))

        target_machine.cve_2015_1427_tried = True

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root, total_new_osvdb_vuln_found, total_new_logged_in, \
        total_new_tools_installed, total_new_backdoors_installed = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, [target_machine], env_config=env_config,
                                                   action=a)
        s_prime = s
        s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_cve_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 num_new_osvdb_vuln_found=total_new_osvdb_vuln_found,
                                                 num_new_logged_in=total_new_logged_in,
                                                 num_new_tools_installed=total_new_tools_installed,
                                                 num_new_backdoors_installed=total_new_backdoors_installed,
                                                 cost=cost,
                                                 env_config=env_config,
                                                 alerts=total_alerts, action=a)
        return s, reward, False

    @staticmethod
    def cve_2016_10033_helper(s: EnvState, a: Action, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Helper for executing the CVE-2016-10033 exploit action

        :param s: the current state
        :param a: the CVE-2016-10033 exploit action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        # Extract target machine
        target_machine = None
        for m in s.obs_state.machines:
            if m.ip == a.ip:
                target_machine = m.copy()
        if target_machine is None:
            target_machine = MachineObservationState(ip=a.ip)

        cache_key = (a.id, target_machine.ip, env_config.cluster_config.agent_username)
        exploit_successful = False

        # Check cache first
        cache_hit = False
        if env_config.use_user_command_cache:

            # Check in-memory cache
            if env_config.user_command_cache.get(cache_key) is not None:
                cache_hit = True
                target_machine, cost, exploit_successful = env_config.user_command_cache.get(cache_key)
            # Check on-disk cache
            else:
                cache_file = ClusterUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                 user=env_config.cluster_config.agent_username)
                if cache_file is not None:
                    cache_hit = True
                    cache_res = ClusterUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                    conn=env_config.cluster_config.agent_conn)
                    # Use measured cost
                    if env_config.action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.CVE_2016_10033.SERVICE_NAME):
                        a.cost = env_config.action_costs.find_get_cost(
                            action_id=a.id, ip=a.ip, user=env_config.cluster_config.agent_username,
                            service=constants.CVE_2016_10033.SERVICE_NAME)
                        cost = a.cost

                    if int(cache_res) == 0:
                        exploit_successful = False
                    else:
                        exploit_successful = True
                        credential = Credential(username=constants.CVE_2016_10033.BACKDOOR_USER,
                                                pw=constants.CVE_2016_10033.BACKDOOR_PW,
                                                port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                                service=constants.SSH.SERVICE_NAME)
                        vuln = Vulnerability(
                            name=constants.EXPLOIT_VULNERABILITES.CVE_2016_10033,
                            cve=constants.EXPLOIT_VULNERABILITES.CVE_2016_10033, cvss=9.8,
                            credentials=[Credential(username=constants.CVE_2016_10033.BACKDOOR_USER,
                                                    pw=constants.CVE_2016_10033.BACKDOOR_PW,
                                                    service=constants.CVE_2016_10033.SERVICE_NAME)
                                         ], port=constants.CVE_2016_10033.PORT, protocol=TransportProtocol.TCP)
                        target_machine.shell_access = True
                        target_machine.untried_credentials = True
                        target_machine.shell_access_credentials.append(credential)
                        target_machine.backdoor_credentials.append(credential)
                        target_machine.backdoor_tried = True
                        target_machine.backdoor_installed = True
                        target_machine.cve_vulns.append(vuln)

            if cache_hit:
                # Use measured # alerts
                if env_config.action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.CVE_2016_10033.SERVICE_NAME):
                    a.alerts = env_config.action_alerts.user_ip_get_alert(action_id=a.id, ip=a.ip,
                                                                          user=env_config.cluster_config.agent_username,
                                                                          service=constants.CVE_2016_10033.SERVICE_NAME)
                    total_alerts = (a.alerts[0], a.alerts[1])

        if not cache_hit:
            # Try execute exploit from agent host
            cost = 0
            total_alerts = (0, 0)
            if env_config.ids_router:
                last_alert_ts = ClusterUtil.get_latest_alert_ts(env_config=env_config)
            cmd = a.cmd[0]
            cmd = cmd.format(a.ip)
            outdata, errdata, total_time = ClusterUtil.execute_ssh_cmd(
                cmd=cmd, conn=env_config.cluster_config.agent_conn)

            # Parse Result
            proxy_conn = ConnectionObservationState(conn=env_config.cluster_config.agent_conn,
                                                    username=env_config.cluster_config.agent_username,
                                                    root=True, port=22, service=constants.SSH.SERVICE_NAME,
                                                    proxy=None, ip=env_config.cluster_config.agent_ip)
            if ExploitUtil.check_if_rce_exploit_succeeded(user=constants.CVE_2016_10033.BACKDOOR_USER,
                                                          pw=constants.CVE_2016_10033.BACKDOOR_PW,
                                                          source_ip=env_config.cluster_config.agent_ip,
                                                          port=constants.SSH.DEFAULT_PORT,
                                                          target_ip=a.ip,
                                                          proxy_conn=proxy_conn):
                # Exploit successful
                credential = Credential(username=constants.CVE_2016_10033.BACKDOOR_USER,
                                        pw=constants.CVE_2016_10033.BACKDOOR_PW,
                                        port=constants.SSH.DEFAULT_PORT, protocol=TransportProtocol.TCP,
                                        service=constants.SSH.SERVICE_NAME)
                vuln = Vulnerability(
                    name=constants.EXPLOIT_VULNERABILITES.CVE_2016_10033,
                    cve=constants.EXPLOIT_VULNERABILITES.CVE_2016_10033, cvss=9.8,
                    credentials=[Credential(username=constants.CVE_2016_10033.BACKDOOR_USER,
                                            pw=constants.CVE_2016_10033.BACKDOOR_PW,
                                            service=constants.CVE_2016_10033.SERVICE_NAME)
                                 ], port=constants.CVE_2016_10033.PORT, protocol=TransportProtocol.TCP)
                target_machine.shell_access = True
                target_machine.untried_credentials = True
                target_machine.shell_access_credentials.append(credential)
                target_machine.backdoor_credentials.append(credential)
                target_machine.backdoor_tried = True
                target_machine.backdoor_installed = True
                target_machine.cve_vulns.append(vuln)
                exploit_successful = True

            # Measure  cost and alerts
            cost += float(total_time)
            if env_config.ids_router:
                fast_logs = ClusterUtil.check_ids_fast_log(env_config=env_config)
                if last_alert_ts is not None:
                    fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                num_alerts = len(fast_logs)
                total_alerts = (num_alerts, sum_priority_alerts)
                ClusterUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                  action=a, env_config=env_config,
                                                  user=env_config.cluster_config.agent_username,
                                                  service=constants.CVE_2016_10033.SERVICE_NAME)
                env_config.action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                           alert=(sum_priority_alerts, num_alerts),
                                                           user=env_config.cluster_config.agent_username,
                                                           service=constants.CVE_2016_10033.SERVICE_NAME)

            ClusterUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                             user=env_config.cluster_config.agent_username,
                                             service=constants.CVE_2016_10033.SERVICE_NAME)
            env_config.action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=round(total_time, 1),
                                                  user=env_config.cluster_config.agent_username,
                                                  service=constants.CVE_2016_10033.SERVICE_NAME)

            # Persist cache result
            ClusterUtil.write_user_command_cache(action=a, env_config=env_config,
                                                 user=env_config.cluster_config.agent_username,
                                                 result=str(int(exploit_successful)), ip=a.ip)

            # Update cache
            if env_config.use_user_command_cache:
                env_config.user_command_cache.add(cache_key, (target_machine, cost, exploit_successful))

        target_machine.cve_2016_10033_tried = True

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root, total_new_osvdb_vuln_found, total_new_logged_in, \
        total_new_tools_installed, total_new_backdoors_installed = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.obs_state.machines, [target_machine], env_config=env_config,
                                                   action=a)
        s_prime = s
        s_prime.obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_cve_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 num_new_osvdb_vuln_found=total_new_osvdb_vuln_found,
                                                 num_new_logged_in=total_new_logged_in,
                                                 num_new_tools_installed=total_new_tools_installed,
                                                 num_new_backdoors_installed=total_new_backdoors_installed,
                                                 cost=cost,
                                                 env_config=env_config,
                                                 alerts=total_alerts, action=a)
        return s, reward, False

    @staticmethod
    def cve_2010_0426_helper(s: EnvState, a: Action, env_config: EnvConfig, machine: MachineObservationState,
                             result: MachineObservationState) \
            -> Tuple[MachineObservationState, float, Tuple[float, float], bool, Credential, str]:
        """
        Helper for executing the CVE-2010-0426 privelege_escalation action

        :param s: the current state
        :param a: the CVE-2010-0425 privilege escalation action
        :param env_config: the environment config
        :return: new_machine_obs, cost, alerts, successful, root_credential, service_name
        """
        agent_proxy_conn = ConnectionObservationState(conn=env_config.cluster_config.agent_conn,
                                                      username=env_config.cluster_config.agent_username,
                                                      root=True, port=22,
                                                      service=constants.SSH.SERVICE_NAME,
                                                      proxy=None, ip=env_config.cluster_config.agent_ip)
        cost = 0
        alerts = (0, 0)
        if env_config.ids_router:
            last_alert_ts = ClusterUtil.get_latest_alert_ts(env_config=env_config)
        e_succ = False
        root_credential = None
        service = None
        sleep_time = 0.5
        # Start with SSH connections
        for ssh_conn in machine.ssh_connections:

            # Setup interactive shell
            channel = ssh_conn.conn.invoke_shell()


            # clear output
            if channel.recv_ready():
                output = channel.recv(constants.COMMON.DEFAULT_RECV_SIZE)

            # Exploit
            cmd = a.cmd[0].format(constants.CVE_2010_0426.EXPLOIT_FILE)
            e_succ = True
            try:
                ClusterUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                time.sleep(sleep_time)
                output = ClusterUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                cmd = a.cmd[1]
                ClusterUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                time.sleep(sleep_time)
                output = ClusterUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                e_succ = ExploitUtil.check_if_rce_exploit_succeeded(
                    user=constants.CVE_2010_0426.BACKDOOR_USER, pw=constants.CVE_2010_0426.BACKDOOR_PW,
                    source_ip=env_config.cluster_config.agent_ip, port=constants.SSH.DEFAULT_PORT,
                    target_ip=a.ip, proxy_conn=agent_proxy_conn)
            except Exception as e:
                print("CVE-2010-0426 error:{}".format(str(e)))
                e_succ = False
            if e_succ:
                root_credential = Credential(username=constants.CVE_2010_0426.BACKDOOR_USER,
                                             pw=constants.CVE_2010_0426.BACKDOOR_PW, port=constants.SSH.DEFAULT_PORT,
                                             protocol=TransportProtocol.TCP, service=constants.SSH.SERVICE_NAME)
                root_connection = ClusterUtil.setup_custom_connection(
                    user=constants.CVE_2010_0426.BACKDOOR_USER, pw=constants.CVE_2010_0426.BACKDOOR_PW,
                    source_ip=env_config.cluster_config.agent_ip, port=constants.SSH.DEFAULT_PORT,
                    target_ip=machine.ip, proxy_conn=agent_proxy_conn, root=True)
                vuln = Vulnerability(
                    name=constants.EXPLOIT_VULNERABILITES.CVE_2010_0426,
                    cve=constants.EXPLOIT_VULNERABILITES.CVE_2010_0426, cvss=6,
                    credentials=[root_credential], port=constants.SSH.DEFAULT_PORT,
                    protocol=TransportProtocol.TCP)
                result.cve_vulns.append(vuln)
                result.cve_2010_0426_tried = True
                result.shell_access_credentials.append(root_credential)
                result.backdoor_credentials.append(root_credential)
                result.backdoor_tried = True
                result.backdoor_installed = True
                result.shell_access = True
                result.logged_in = True
                result.root = True
                result.ssh_connections.append(root_connection)
                service = constants.SSH.SERVICE_NAME
                break

                # Measure  cost and alerts
                cost += float(sleep_time * 2)
                if env_config.ids_router:
                    fast_logs = ClusterUtil.check_ids_fast_log(env_config=env_config)
                    if last_alert_ts is not None:
                        fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                    sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                    num_alerts = len(fast_logs)
                    alerts = (num_alerts, sum_priority_alerts)
                    ClusterUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                      action=a, env_config=env_config,
                                                      user=env_config.cluster_config.agent_username,
                                                      service=constants.CVE_2010_0426.SERVICE_NAME)
                    env_config.action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                               alert=(sum_priority_alerts, num_alerts),
                                                               user=env_config.cluster_config.agent_username,
                                                               service=constants.CVE_2010_0426.SERVICE_NAME)

                ClusterUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                                 user=env_config.cluster_config.agent_username,
                                                 service=constants.CVE_2010_0426.SERVICE_NAME)
                env_config.action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=cost,
                                                      user=env_config.cluster_config.agent_username,
                                                      service=constants.CVE_2010_0426.SERVICE_NAME)
        result.cve_2010_0426_tried = True
        return result, cost, alerts, e_succ, root_credential, service

    @staticmethod
    def cve_2015_5602_helper(s: EnvState, a: Action, env_config: EnvConfig, machine: MachineObservationState,
                             result: MachineObservationState) \
            -> Tuple[EnvState, int, bool]:
        """
        Helper for executing the CVE-2015-5602 privilege escalation action

        :param s: the current state
        :param a: the CVE-2015-5602 privilege escalation action
        :param env_config: the environment config
        :return: s_prime, reward, done
        """
        agent_proxy_conn = ConnectionObservationState(conn=env_config.cluster_config.agent_conn,
                                                      username=env_config.cluster_config.agent_username,
                                                      root=True, port=22,
                                                      service=constants.SSH.SERVICE_NAME,
                                                      proxy=None, ip=env_config.cluster_config.agent_ip)
        cost = 0
        alerts = (0, 0)
        if env_config.ids_router:
            last_alert_ts = ClusterUtil.get_latest_alert_ts(env_config=env_config)
        e_succ = False
        root_credential = None
        service = None
        sleep_time = 0.5
        # Start with SSH connections
        for ssh_conn in machine.ssh_connections:

            # Setup interactive shell
            channel = ssh_conn.conn.invoke_shell()

            # clear output
            if channel.recv_ready():
                output = channel.recv(constants.COMMON.DEFAULT_RECV_SIZE)

            # Exploit
            cmd = a.cmd[0]
            e_succ = True
            try:
                ClusterUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                time.sleep(sleep_time)
                output = ClusterUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                cmd = a.cmd[1]
                ClusterUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                time.sleep(sleep_time)
                output = ClusterUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                cmd = a.cmd[2]
                ClusterUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                time.sleep(sleep_time)
                output = ClusterUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                cmd = a.cmd[3]
                ClusterUtil.execute_cmd_interactive_channel(cmd=cmd, channel=channel)
                time.sleep(sleep_time)
                output = ClusterUtil.read_result_interactive_channel(env_config=env_config, channel=channel)
                e_succ = ExploitUtil.check_if_rce_exploit_succeeded(
                    user=constants.CVE_2015_5602.BACKDOOR_USER, pw=constants.CVE_2015_5602.BACKDOOR_PW,
                    source_ip=env_config.cluster_config.agent_ip, port=constants.SSH.DEFAULT_PORT,
                    target_ip=a.ip, proxy_conn=agent_proxy_conn)
            except Exception as e:
                print("CVE-2015-5602 error:{}".format(str(e)))
                e_succ = False
            if e_succ:
                root_credential = Credential(username=constants.CVE_2015_5602.BACKDOOR_USER,
                                             pw=constants.CVE_2015_5602.BACKDOOR_PW,
                                             port=constants.SSH.DEFAULT_PORT,
                                             protocol=TransportProtocol.TCP, service=constants.SSH.SERVICE_NAME)
                root_connection = ClusterUtil.setup_custom_connection(
                    user=constants.CVE_2015_5602.BACKDOOR_USER, pw=constants.CVE_2015_5602.BACKDOOR_PW,
                    source_ip=env_config.cluster_config.agent_ip, port=constants.SSH.DEFAULT_PORT,
                    target_ip=machine.ip, proxy_conn=agent_proxy_conn, root=True)
                vuln = Vulnerability(
                    name=constants.EXPLOIT_VULNERABILITES.CVE_2015_5602,
                    cve=constants.EXPLOIT_VULNERABILITES.CVE_2015_5602, cvss=6,
                    credentials=[root_credential], port=constants.SSH.DEFAULT_PORT,
                    protocol=TransportProtocol.TCP)
                result.cve_vulns.append(vuln)
                result.cve_2015_5602_tried = True
                result.shell_access_credentials.append(root_credential)
                result.backdoor_credentials.append(root_credential)
                result.backdoor_tried = True
                result.backdoor_installed = True
                result.shell_access = True
                result.logged_in = True
                result.root = True
                result.ssh_connections.append(root_connection)
                service = constants.SSH.SERVICE_NAME
                break

                # Measure  cost and alerts
                cost += float(sleep_time * 2)
                if env_config.ids_router:
                    fast_logs = ClusterUtil.check_ids_fast_log(env_config=env_config)
                    if last_alert_ts is not None:
                        fast_logs = list(filter(lambda x: x[1] > last_alert_ts, fast_logs))
                    sum_priority_alerts = sum(list(map(lambda x: x[0], fast_logs)))
                    num_alerts = len(fast_logs)
                    alerts = (num_alerts, sum_priority_alerts)
                    ClusterUtil.write_alerts_response(sum_priorities=sum_priority_alerts, num_alerts=num_alerts,
                                                      action=a, env_config=env_config,
                                                      user=env_config.cluster_config.agent_username,
                                                      service=constants.CVE_2015_5602.SERVICE_NAME)
                    env_config.action_alerts.user_ip_add_alert(action_id=a.id, ip=a.ip,
                                                               alert=(sum_priority_alerts, num_alerts),
                                                               user=env_config.cluster_config.agent_username,
                                                               service=constants.CVE_2015_5602.SERVICE_NAME)

                ClusterUtil.write_estimated_cost(total_time=total_time, action=a, env_config=env_config,
                                                 user=env_config.cluster_config.agent_username,
                                                 service=constants.CVE_2015_5602.SERVICE_NAME)
                env_config.action_costs.find_add_cost(action_id=a.id, ip=a.ip, cost=cost,
                                                      user=env_config.cluster_config.agent_username,
                                                      service=constants.CVE_2015_5602.SERVICE_NAME)
        result.cve_2015_5602_tried = True
        return result, cost, alerts, e_succ, root_credential, service