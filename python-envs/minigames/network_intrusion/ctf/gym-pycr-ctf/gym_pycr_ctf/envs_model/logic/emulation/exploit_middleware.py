from typing import Tuple
from gym_pycr_ctf.dao.network.env_state import EnvState
from gym_pycr_ctf.dao.network.env_config import EnvConfig
from gym_pycr_ctf.dao.action.attacker.attacker_action import AttackerAction
from gym_pycr_ctf.envs_model.logic.emulation.util.common.emulation_util import EmulationUtil
from gym_pycr_ctf.dao.observation.attacker.attacker_machine_observation_state import AttackerMachineObservationState
from gym_pycr_ctf.envs_model.logic.common.env_dynamics_util import EnvDynamicsUtil
from gym_pycr_ctf.dao.network.credential import Credential
from gym_pycr_ctf.dao.network.transport_protocol import TransportProtocol
from gym_pycr_ctf.dao.network.vulnerability import Vulnerability
import gym_pycr_ctf.constants.constants as constants
from gym_pycr_ctf.envs_model.logic.emulation.util.attacker.nmap_util import NmapUtil
from gym_pycr_ctf.envs_model.logic.emulation.util.attacker.exploit_util import ExploitUtil
from gym_pycr_ctf.envs_model.logic.emulation.util.common.connection_util import ConnectionUtil

class ExploitMiddleware:
    """
    Class that implements functionality for executing exploits actions on the emulation
    """

    @staticmethod
    def execute_telnet_same_user_dictionary(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a Telnet Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_ssh_same_user_dictionary(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a SSH Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_ftp_same_user_dictionary(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a FTP Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_cassandra_same_user_dictionary(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a Cassandra Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_irc_same_user_dictionary(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a IRC Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_mongo_same_user_dictionary(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a Mongo Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_mysql_same_user_dictionary(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a MySQL Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_smtp_same_user_dictionary(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a SMTP Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_postgres_same_user_dictionary(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[
        EnvState, int, bool]:
        """
        Performs a Postgres Dictionary Password Attack action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = NmapUtil.nmap_scan_action_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_sambacry(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a Sambacry Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.sambacry_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_shellshock(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a ShellShock Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.shellshock_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_dvwa_sql_injection(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a DVWA SQL Injection Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.dvwa_sql_injection_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_cve_2015_3306_exploit(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a CVE-2015-3306 Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.cve_2015_3306_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_cve_2015_1427_exploit(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a CVE-2015-1427 Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.cve_2015_1427_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_cve_2016_10033_exploit(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a CVE-2016-10033 Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ExploitUtil.cve_2016_10033_helper(s=s, a=a, env_config=env_config)
        return s_prime, reward, done

    @staticmethod
    def execute_cve_2010_0426_exploit(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a CVE-2010-0426 Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        new_machines_obs = []
        total_cost = 0
        total_alerts = (0, 0)
        for machine in s.attacker_obs_state.machines:
            m_cost = 0
            m_alerts = (0,0)
            cache_hit = False
            if a.ip == machine.ip and machine.logged_in and not machine.root and not machine.backdoor_installed:
                new_m_obs = AttackerMachineObservationState(ip=machine.ip)
                new_m_obs.cve_2010_0426_tried = True
                usernames = ",".join(sorted(list(set(list(map(lambda x: x.username, machine.ssh_connections)) \
                                                     + list(map(lambda x: x.username, machine.telnet_connections)) \
                                                     + list(map(lambda x: x.username, machine.ftp_connections))))))

                jump_connection = ConnectionUtil.find_jump_host_connection(ip=machine.ip, s=s,
                                                                           env_config=env_config)
                base_cache_id = (a.id, machine.ip, a.subnet, jump_connection.username, usernames)
                key = base_cache_id

                # Check in-memory cache
                if env_config.attacker_use_user_command_cache and env_config.attacker_user_command_cache.get(key) is not None:
                    cache_hit = True
                    cache_obs, cost, exploit_successful, username, pw, service = env_config.attacker_user_command_cache.get(key)
                    new_m_obs.root = cache_obs.root
                    new_m_obs.shell_access = cache_obs.shell_access
                    new_m_obs.logged_in = cache_obs.logged_in
                    new_m_obs.cve_2010_0426_tried = True
                    if exploit_successful:
                        new_m_obs.untried_credentials = True
                        new_m_obs.backdoor_tried = True
                        new_m_obs.backdoor_installed = True
                    new_m_obs.shell_access_credentials = cache_obs.shell_access_credentials
                    new_m_obs.backdoor_credentials = cache_obs.backdoor_credentials
                    new_m_obs.cve_vulns = cache_obs.cve_vulns
                    for cached_conn in cache_obs.ssh_connections:
                        if cached_conn.root and cached_conn.username == username and cached_conn.service == service:
                            new_m_obs.ssh_connections.append(cached_conn)
                    new_machines_obs.append(new_m_obs)
                    m_cost = cost
                    total_cost += m_cost
                    continue
                else:
                    # Check on-disk cache
                    cache_file = EmulationUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                       user=jump_connection.username,
                                                                       jumphost=jump_connection.ip)
                    if cache_file is not None:
                        cache_hit = True
                        cache_res = EmulationUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                          conn=env_config.emulation_config.agent_conn)
                        # Use measured cost
                        if env_config.attacker_action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                                        user=env_config.emulation_config.agent_username,
                                                                        service=constants.CVE_2010_0426.SERVICE_NAME):
                            a.cost = env_config.attacker_action_costs.find_get_cost(
                                action_id=a.id, ip=a.ip, user=env_config.emulation_config.agent_username,
                                service=constants.CVE_2010_0426.SERVICE_NAME)
                            m_cost = a.cost
                        cache_res_parts = cache_res.split(",")
                        cache_res_outcome = int(cache_res_parts[0])
                        cache_res_username = cache_res_parts[1]
                        cache_res_pw = cache_res_parts[2]
                        cache_res_service = cache_res_parts[3]
                        username = cache_res_username
                        pw = cache_res_pw
                        service = cache_res_service
                        if cache_res_outcome == 0:
                            exploit_successful = False
                        else:
                            exploit_successful = True
                            if cache_res_service == constants.SSH.SERVICE_NAME:
                                port = constants.SSH.DEFAULT_PORT
                            elif cache_res_service == constants.FTP.SERVICE_NAME:
                                port = constants.FTP.DEFAULT_PORT
                            elif cache_res_service == constants.TELNET.SERVICE_NAME:
                                port = constants.TELNET.DEFAULT_PORT
                            else:
                                raise ValueError("Service: {} not recognized".format(cache_res_service))

                            proxy_conn = jump_connection
                            cache_valid = ExploitUtil.check_if_rce_exploit_succeeded(
                                user=cache_res_username, pw=cache_res_pw, source_ip=jump_connection.ip,
                                port=jump_connection.port, target_ip=a.ip, proxy_conn=proxy_conn)

                            if not cache_valid:
                                raise ValueError("Corrupted cache entry; user:{},pw:{},outcome:{}".format(
                                    cache_res_username, cache_res_pw, cache_res_outcome))

                            connection_dto = EmulationUtil.setup_custom_connection(
                                user=cache_res_username, pw=cache_res_pw, source_ip=jump_connection.ip,
                                port=jump_connection.port, target_ip=a.ip, proxy_conn=proxy_conn, root=True)

                            credential = Credential(username=cache_res_username, pw=cache_res_pw,
                                                    port=port, protocol=TransportProtocol.TCP, service=cache_res_service)
                            vuln = Vulnerability(
                                name=constants.EXPLOIT_VULNERABILITES.CVE_2010_0426,
                                cve=constants.EXPLOIT_VULNERABILITES.CVE_2010_0426, cvss=6,
                                credentials=[credential], port=port, protocol=TransportProtocol.TCP)
                            new_m_obs.cve_vulns.append(vuln)
                            new_m_obs.cve_2010_0426_tried = True
                            new_m_obs.shell_access_credentials.append(credential)
                            new_m_obs.backdoor_credentials.append(credential)
                            new_m_obs.backdoor_tried = True
                            new_m_obs.backdoor_installed = True
                            new_m_obs.shell_access = True
                            new_m_obs.logged_in = True
                            new_m_obs.root = True
                            new_m_obs.ssh_connections.append(connection_dto)
                            exploit_successful = True
                            new_machines_obs.append(new_m_obs)

                if cache_hit:
                    # Use measured # alerts
                    if env_config.attacker_action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                                        user=env_config.emulation_config.agent_username,
                                                                        service=constants.CVE_2010_0426.SERVICE_NAME):
                        a.alerts = env_config.attacker_action_alerts.user_ip_get_alert(
                            action_id=a.id, ip=a.ip, user=env_config.emulation_config.agent_username,
                            service=constants.CVE_2010_0426.SERVICE_NAME)
                        m_alerts = (a.alerts[0], a.alerts[1])

                if not cache_hit:
                    # Try to escalate privileges using existing connections
                    new_m_obs, m_cost, m_alerts, exploit_successful, root_credential, service = \
                        ExploitUtil.cve_2010_0426_helper(s=s, a=a, env_config=env_config, machine=machine, result=new_m_obs)
                    new_machines_obs.append(new_m_obs)

                    if not exploit_successful:
                        username = "-"
                        pw = "-"
                        service = "-"
                    else:
                        username = root_credential.username
                        pw = root_credential.pw

                    # Persist cache result
                    cache_result = str(int(exploit_successful)) + "," + username + "," + pw \
                                   + "," + service
                    EmulationUtil.write_user_command_cache(action=a, env_config=env_config,
                                                           user=jump_connection.username,
                                                           result=cache_result, ip=a.ip,
                                                           jumphost=jump_connection.ip)

                # Update cache
                if env_config.attacker_use_user_command_cache:
                    env_config.attacker_user_command_cache.add(key, (new_m_obs, m_cost, exploit_successful, username, pw, service))

                # Total cost update
                total_cost += m_cost

                # Total alerts update
                total_alerts = (total_alerts[0] + m_alerts[0], total_alerts[1] + m_alerts[1])

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root, total_new_osvdb_vuln_found, total_new_logged_in, \
        total_new_tools_installed, total_new_backdoors_installed = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, new_machines_obs, env_config=env_config,
                                                   action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_cve_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 num_new_osvdb_vuln_found=total_new_osvdb_vuln_found,
                                                 num_new_logged_in=total_new_logged_in,
                                                 num_new_tools_installed=total_new_tools_installed,
                                                 num_new_backdoors_installed=total_new_backdoors_installed,
                                                 cost=total_cost,
                                                 env_config=env_config,
                                                 alerts=total_alerts, action=a
                                                 )
        return s_prime, reward, False

    @staticmethod
    def execute_cve_2015_5602_exploit(s: EnvState, a: AttackerAction, env_config: EnvConfig) -> Tuple[EnvState, int, bool]:
        """
        Performs a CVE-2015-5602 Exploit action

        :param s: the current state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        new_machines_obs = []
        total_cost = 0
        total_alerts = (0, 0)
        for machine in s.attacker_obs_state.machines:
            m_cost = 0
            m_alerts = (0, 0)
            cache_hit = False
            if a.ip == machine.ip and machine.logged_in and not machine.root and not machine.backdoor_installed:
                new_m_obs = AttackerMachineObservationState(ip=machine.ip)
                new_m_obs.cve_2015_5602_tried = True
                usernames = ",".join(sorted(list(set(list(map(lambda x: x.username, machine.ssh_connections)) \
                                                     + list(map(lambda x: x.username, machine.telnet_connections)) \
                                                     + list(map(lambda x: x.username, machine.ftp_connections))))))
                jump_connection = ConnectionUtil.find_jump_host_connection(ip=machine.ip, s=s,
                                                                           env_config=env_config)
                base_cache_id = (a.id, machine.ip, a.subnet, jump_connection.username, usernames)
                key = base_cache_id

                # Check in-memory cache
                if env_config.attacker_use_user_command_cache and env_config.attacker_user_command_cache.get(key) is not None:
                    cache_hit = True
                    cache_obs, cost, exploit_successful, username, pw, service = env_config.attacker_user_command_cache.get(key)
                    new_m_obs.root = cache_obs.root
                    new_m_obs.cve_2015_5602_tried = True
                    new_m_obs.logged_in = cache_obs.logged_in
                    new_m_obs.shell_access = cache_obs.shell_access
                    if exploit_successful:
                        new_m_obs.untried_credentials = True
                        new_m_obs.backdoor_tried = True
                        new_m_obs.backdoor_installed = True
                    new_m_obs.shell_access_credentials = cache_obs.shell_access_credentials
                    new_m_obs.backdoor_credentials = cache_obs.backdoor_credentials
                    new_m_obs.cve_vulns = cache_obs.cve_vulns
                    for cached_conn in cache_obs.ssh_connections:
                        if cached_conn.root and cached_conn.username == username and cached_conn.service == service:
                            new_m_obs.ssh_connections.append(cached_conn)
                    new_machines_obs.append(new_m_obs)
                    m_cost = cost
                    total_cost += m_cost
                    continue
                else:
                    # Check on-disk cache
                    cache_file = EmulationUtil.check_user_action_cache(a=a, env_config=env_config, ip=a.ip,
                                                                       user=jump_connection.username,
                                                                       jumphost=jump_connection.ip)
                    if cache_file is not None:
                        cache_hit = True
                        cache_res = EmulationUtil.parse_user_command_file(file_name=cache_file, env_config=env_config,
                                                                          conn=env_config.emulation_config.agent_conn)
                        # Use measured cost
                        if env_config.attacker_action_costs.find_exists(action_id=a.id, ip=a.ip,
                                                                        user=env_config.emulation_config.agent_username,
                                                                        service=constants.CVE_2015_5602.SERVICE_NAME):
                            a.cost = env_config.attacker_action_costs.find_get_cost(
                                action_id=a.id, ip=a.ip, user=env_config.emulation_config.agent_username,
                                service=constants.CVE_2015_5602.SERVICE_NAME)
                            m_cost = a.cost
                        cache_res_parts = cache_res.split(",")
                        cache_res_outcome = int(cache_res_parts[0])
                        cache_res_username = cache_res_parts[1]
                        cache_res_pw = cache_res_parts[2]
                        cache_res_service = cache_res_parts[3]
                        username = cache_res_username
                        pw = cache_res_pw
                        service = cache_res_service
                        if cache_res_outcome == 0:
                            exploit_successful = False
                        else:
                            exploit_successful = True
                            if cache_res_service == constants.SSH.SERVICE_NAME:
                                port = constants.SSH.DEFAULT_PORT
                            elif cache_res_service == constants.FTP.SERVICE_NAME:
                                port = constants.FTP.DEFAULT_PORT
                            elif cache_res_service == constants.TELNET.SERVICE_NAME:
                                port = constants.TELNET.DEFAULT_PORT
                            else:
                                raise ValueError("Service: {} not recognized".format(cache_res_service))

                            proxy_conn = jump_connection
                            cache_valid = ExploitUtil.check_if_rce_exploit_succeeded(
                                user=cache_res_username, pw=cache_res_pw, source_ip=jump_connection.ip,
                                port=jump_connection.port, target_ip=a.ip, proxy_conn=proxy_conn)

                            if not cache_valid:
                                raise ValueError("Corrupted cache entry; user:{},pw:{},outcome:{}".format(
                                    cache_res_username, cache_res_pw, cache_res_outcome))

                            connection_dto = EmulationUtil.setup_custom_connection(
                                user=cache_res_username, pw=cache_res_pw, source_ip=jump_connection.ip,
                                port=jump_connection.port, target_ip=a.ip, proxy_conn=proxy_conn, root=True)

                            credential = Credential(username=cache_res_username, pw=cache_res_pw,
                                                    port=port, protocol=TransportProtocol.TCP, service=cache_res_service)
                            vuln = Vulnerability(
                                name=constants.EXPLOIT_VULNERABILITES.CVE_2015_5602,
                                cve=constants.EXPLOIT_VULNERABILITES.CVE_2015_5602, cvss=6,
                                credentials=[credential], port=port, protocol=TransportProtocol.TCP)
                            new_m_obs.cve_vulns.append(vuln)
                            new_m_obs.cve_2015_5602_tried = True
                            new_m_obs.shell_access_credentials.append(credential)
                            new_m_obs.backdoor_credentials.append(credential)
                            new_m_obs.backdoor_tried = True
                            new_m_obs.backdoor_installed = True
                            new_m_obs.shell_access = True
                            new_m_obs.logged_in = True
                            new_m_obs.ssh_connections.append(connection_dto)
                            new_m_obs.root = True
                            exploit_successful = True
                            new_machines_obs.append(new_m_obs)

                if cache_hit:
                    # Use measured # alerts
                    if env_config.attacker_action_alerts.user_ip_exists(action_id=a.id, ip=a.ip,
                                                                        user=env_config.emulation_config.agent_username,
                                                                        service=constants.CVE_2015_5602.SERVICE_NAME):
                        a.alerts = env_config.attacker_action_alerts.user_ip_get_alert(
                            action_id=a.id, ip=a.ip, user=env_config.emulation_config.agent_username,
                            service=constants.CVE_2015_5602.SERVICE_NAME)
                        m_alerts = (a.alerts[0], a.alerts[1])

                if not cache_hit:
                    # Try to escalate privileges using existing connections
                    new_m_obs, m_cost, m_alerts, exploit_successful, root_credential, service = \
                        ExploitUtil.cve_2015_5602_helper(s=s, a=a, env_config=env_config, machine=machine,
                                                         result=new_m_obs)
                    new_machines_obs.append(new_m_obs)

                    if not exploit_successful:
                        username = "-"
                        pw = "-"
                        service = "-"
                    else:
                        username = root_credential.username
                        pw = root_credential.pw

                    # Persist cache result
                    cache_result = str(int(exploit_successful)) + "," + username + "," + pw \
                                   + "," + service
                    EmulationUtil.write_user_command_cache(action=a, env_config=env_config,
                                                           user=jump_connection.username,
                                                           result=cache_result, ip=a.ip,
                                                           jumphost=jump_connection.ip)

                # Update cache
                if env_config.attacker_use_user_command_cache:
                    env_config.attacker_user_command_cache.add(key, (new_m_obs, m_cost, exploit_successful, username, pw, service))

                # Total cost update
                total_cost += m_cost

                # Total alerts update
                total_alerts = (total_alerts[0] + m_alerts[0], total_alerts[1] + m_alerts[1])

        new_machines_obs, total_new_ports, total_new_os, total_new_vuln, total_new_machines, \
        total_new_shell_access, total_new_flag_pts, total_new_root, total_new_osvdb_vuln_found, total_new_logged_in, \
        total_new_tools_installed, total_new_backdoors_installed = \
            EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, new_machines_obs, env_config=env_config,
                                                   action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = new_machines_obs

        reward = EnvDynamicsUtil.reward_function(num_new_ports_found=total_new_ports, num_new_os_found=total_new_os,
                                                 num_new_cve_vuln_found=total_new_vuln,
                                                 num_new_machines=total_new_machines,
                                                 num_new_shell_access=total_new_shell_access,
                                                 num_new_root=total_new_root,
                                                 num_new_flag_pts=total_new_flag_pts,
                                                 num_new_osvdb_vuln_found=total_new_osvdb_vuln_found,
                                                 num_new_logged_in=total_new_logged_in,
                                                 num_new_tools_installed=total_new_tools_installed,
                                                 num_new_backdoors_installed=total_new_backdoors_installed,
                                                 cost=total_cost,
                                                 env_config=env_config,
                                                 alerts=total_alerts, action=a
                                                 )
        return s_prime, reward, False
