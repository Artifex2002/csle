from typing import Tuple
import numpy as np
from gym_pycr_ctf.dao.network.env_state import EnvState
from gym_pycr_ctf.dao.network.env_config import EnvConfig
from gym_pycr_ctf.dao.action.attacker.attacker_action import AttackerAction
from gym_pycr_ctf.dao.observation.attacker.attacker_machine_observation_state import AttackerMachineObservationState
from gym_pycr_ctf.dao.observation.common.port_observation_state import PortObservationState
from gym_pycr_ctf.dao.observation.common.vulnerability_observation_state import VulnerabilityObservationState
from gym_pycr_ctf.dao.action.attacker.attacker_action_outcome import AttackerActionOutcome
from gym_pycr_ctf.envs_model.logic.common.env_dynamics_util import EnvDynamicsUtil
from gym_pycr_ctf.envs_model.logic.simulation.util.simulator_util import SimulatorUtil
from gym_pycr_ctf.dao.network.network_outcome import NetworkOutcome


class ExploitSimulatorUtil:
    """
    Class containing utility functions for simulating exploit actions
    """

    @staticmethod
    def simulate_exploit_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig, miss_p: float,
                                vuln_name : str) -> Tuple[EnvState, int]:
        """
        Helper function for simulating dictionary scans against some service and with the constraint that
        only username-password combinations where username==password are tried.

        :param s: the current environment state
        :param a: the scan action to take
        :param env_config: the current environment configuration
        :param miss_p: the simulated probability that the scan action will not detect a real service or node
        :param vuln_name: name of the vulnerability
        :return: s_prime, reward
        """

        # Exploit on a single host
        if not a.subnet:
            return ExploitSimulatorUtil.simulate_exploit_single_host_helper(s=s, a=a, env_config=env_config,
                                                                            miss_p=miss_p, vuln_name=vuln_name)
        # Scan action on a whole subnet
        else:
            return ExploitSimulatorUtil.simulate_exploit_subnet_helper(s=s, a=a, env_config=env_config,
                                                                       miss_p=miss_p, vuln_name=vuln_name)

    @staticmethod
    def simulate_exploit_single_host_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig, miss_p: float,
                                         vuln_name: str) -> Tuple[EnvState, int]:
        """
        Helper for simulating exploits against a single host

        :param s: the current environment state
        :param a: the scan action to take
        :param env_config: the current environment configuration
        :param miss_p: the simulated probability that the scan action will not detect a real service or node
        :param vuln_name: name of the vulnerability
        :return: s_prime, reward
        """
        net_outcome = NetworkOutcome()
        reachable_nodes = SimulatorUtil.reachable_nodes(state=s, env_config=env_config)

        new_m_obs = None
        for node in env_config.network_conf.nodes:
            if node.ip == a.ip and node.ip in reachable_nodes:
                new_m_obs = AttackerMachineObservationState(ip=node.ip)
                new_m_obs.reachable = node.reachable_nodes
                vuln_match = False
                vuln_service = None
                for vuln in node.vulnerabilities:
                    if vuln.name == vuln_name and not np.random.rand() < miss_p:
                        vuln_obs = VulnerabilityObservationState(name=vuln.name, port=vuln.port,
                                                                 protocol=vuln.protocol, cvss=vuln.cvss)
                        new_m_obs.cve_vulns.append(vuln_obs)
                        if a.action_outcome == AttackerActionOutcome.SHELL_ACCESS:
                            new_m_obs.shell_access = True
                            new_m_obs.untried_credentials = True
                            new_m_obs.shell_access_credentials = vuln.credentials
                        elif a.action_outcome == AttackerActionOutcome.PRIVILEGE_ESCALATION_ROOT:
                            new_m_obs.root = True

                        if a.backdoor:
                            new_m_obs.backdoor_installed = True
                            new_m_obs.backdoor_tried = True

                        vuln_match = True
                        vuln_service = vuln.service

                if vuln_match:
                    for service in node.services:
                        if service.name == vuln_service:
                            port_obs = PortObservationState(port=service.port, open=True, service=service.name,
                                                            protocol=service.protocol)
                            new_m_obs.ports.append(port_obs)
                new_m_obs = EnvDynamicsUtil.exploit_tried_flags(a=a, m_obs=new_m_obs)
        new_machines_obs = s.attacker_obs_state.machines
        if new_m_obs is not None:
            new_machines_obs = []
            merged = False
            for o_m in s.attacker_obs_state.machines:
                # Machine was already known, merge state
                if o_m.ip == a.ip:
                    new_net_outcome = EnvDynamicsUtil.merge_new_machine_obs_with_old_machine_obs(o_m, new_m_obs, action=a)
                    new_machines_obs.append(new_net_outcome.attacker_machine_observation)
                    merged = True
                    net_outcome.update_counts(new_net_outcome)
                else:
                    new_machines_obs.append(o_m)
            # New machine, was not known before
            if not merged:
                net_outcome.total_new_machines_found += 1
                new_machines_obs.append(new_m_obs)
        s_prime = s
        s_prime.attacker_obs_state.machines = new_machines_obs
        net_outcome.attacker_machine_observations=new_machines_obs
        reward = EnvDynamicsUtil.reward_function(net_outcome=net_outcome, env_config=env_config,action=a)
        return s_prime, reward

    @staticmethod
    def simulate_exploit_subnet_helper(s: EnvState, a: AttackerAction, env_config: EnvConfig, miss_p: float,
                                            vuln_name: str) -> Tuple[EnvState, int]:
        """
        Helper for simulating exploits against an entire subnet

        :param s: the current environment state
        :param a: the scan action to take
        :param env_config: the current environment configuration
        :param miss_p: the simulated probability that the scan action will not detect a real service or node
        :param vuln_name: name of the vulnerability
        :return: s_prime, reward
        """
        net_outcome = NetworkOutcome()
        reachable_nodes = SimulatorUtil.reachable_nodes(state=s, env_config=env_config)

        new_m_obs = None
        new_m_obs = []
        for node in env_config.network_conf.nodes:
            if not node.ip in reachable_nodes:
                continue
            m_obs = AttackerMachineObservationState(ip=node.ip)
            m_obs.reachable = node.reachable_nodes
            vulnerable_services = []
            for vuln in node.vulnerabilities:
                if vuln.name == vuln_name and not np.random.rand() < miss_p:
                    vuln_obs = VulnerabilityObservationState(name=vuln.name, port=vuln.port,
                                                             protocol=vuln.protocol, cvss=vuln.cvss)
                    if a.action_outcome == AttackerActionOutcome.SHELL_ACCESS:
                        m_obs.shell_access = True
                        m_obs.untried_credentials = True
                        m_obs.shell_access_credentials = vuln.credentials
                    m_obs.cve_vulns.append(vuln_obs)
                    vulnerable_services.append(vuln.name)

            for service in node.services:
                match = False
                for vuln_service in vulnerable_services:
                    if service.name == vuln_service:
                        match = True
                if match:
                    port_obs = PortObservationState(port=service.port, open=True, service=service.name,
                                                    protocol=service.protocol)
                    m_obs.ports.append(port_obs)
            m_obs = EnvDynamicsUtil.exploit_tried_flags(a=a, m_obs=m_obs)
            new_m_obs.append(m_obs)

        net_outcome = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, new_m_obs,
                                                             env_config=env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = net_outcome.attacker_machine_observations
        reward = EnvDynamicsUtil.reward_function(net_outcome=net_outcome, env_config=env_config, action=a)
        return s_prime, reward
