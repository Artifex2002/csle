from typing import Tuple
import pycr_common.constants.constants as constants
from gym_pycr_ctf.envs_model.logic.simulation.util.simulator_util import SimulatorUtil
from gym_pycr_ctf.envs_model.logic.simulation.util.shell_simulator_util import ShellSimulatorUtil
from gym_pycr_ctf.dao.network.env_state import EnvState
from gym_pycr_ctf.dao.network.env_config import PyCREnvConfig
from gym_pycr_ctf.dao.action.attacker.attacker_action import AttackerAction
from gym_pycr_ctf.dao.observation.attacker.attacker_machine_observation_state import AttackerMachineObservationState
from gym_pycr_ctf.envs_model.logic.common.env_dynamics_util import EnvDynamicsUtil


class PostExploitSimulator:
    """
    Class that implements functionality for simulating post-exploit actions
    """

    @staticmethod
    def simulate_ssh_login(s: EnvState, a: AttackerAction, env_config: PyCREnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Simulates an action of logging in to a SSH server

        :param s: the environment state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ShellSimulatorUtil.simulate_service_login_helper(s=s, a=a, env_config=env_config,
                                                                                 service_name=constants.SSH.SERVICE_NAME)
        return s_prime, reward, done

    @staticmethod
    def simulate_ftp_login(s: EnvState, a: AttackerAction, env_config: PyCREnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Simulates an action of logging in to a FTP server

        :param s: the environment state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ShellSimulatorUtil.simulate_service_login_helper(s=s, a=a, env_config=env_config,
                                                                                 service_name=constants.FTP.SERVICE_NAME)
        return s_prime, reward, done

    @staticmethod
    def simulate_telnet_login(s: EnvState, a: AttackerAction, env_config: PyCREnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Simulates an action of logging in to a FTP server

        :param s: the environment state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        s_prime, reward, done = ShellSimulatorUtil.simulate_service_login_helper(s=s, a=a, env_config=env_config,
                                                                                 service_name=constants.TELNET.SERVICE_NAME)
        return s_prime, reward, done

    @staticmethod
    def simulate_bash_find_flag(s: EnvState, a: AttackerAction, env_config: PyCREnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Simulates the action of searching the file system for a flag

        :param s: the environment state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        new_obs_machines = []
        for node in env_config.network_conf.nodes:
            new_m_obs = None
            logged_in = False
            logged_in_m = None
            for o_m in s.attacker_obs_state.machines:
                if o_m.ip == node.ip:
                    logged_in = o_m.logged_in
                    logged_in_m = o_m

            if logged_in:
                new_m_obs = AttackerMachineObservationState(ip=node.ip)
                for flag in node.flags:
                    if flag.requires_root and logged_in_m.root:
                        new_m_obs.flags_found.add(flag)
                    elif not flag.requires_root:
                        new_m_obs.flags_found.add(flag)
                new_m_obs.filesystem_searched = True
                new_obs_machines.append(new_m_obs)
        network_outcome = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, new_obs_machines,
                                                                 env_config=env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = network_outcome.attacker_machine_observations
        reward = EnvDynamicsUtil.reward_function(net_outcome=network_outcome, env_config=env_config, action=a)
        s_prime.attacker_obs_state.catched_flags += network_outcome.total_new_flag_pts
        done = EnvDynamicsUtil.is_all_flags_collected(s_prime, env_config)
        if done:
            reward = reward + env_config.attacker_all_flags_reward
        else:
             # Emulate detection
            done, d_reward = EnvDynamicsUtil.emulate_detection(net_outcome=network_outcome, action=a,
                                                               env_config=env_config)
            if done:
                reward = d_reward
            s_prime.attacker_obs_state.detected = done

            # Simulate detection
            if not done:
                s_prime.attacker_obs_state.detected = done
                done, d_reward = SimulatorUtil.simulate_detection(a=a, env_config=env_config)
                if done:
                    reward = d_reward
        s_prime.attacker_obs_state.all_flags = done
        return s_prime, reward, done


    @staticmethod
    def execute_install_tools(s: EnvState, a: AttackerAction, env_config: PyCREnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Simulates the action of install tools needed to install backdoors on a compromised machine

        :param s: the environment state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        new_machines = []

        for machine in s.attacker_obs_state.machines:
            if machine.logged_in and machine.root:
                m = machine.copy()
                m.tools_installed = True
                new_machines.append(m)

        net_outcome = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, new_machines,
                                                   env_config=env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = net_outcome.attacker_machine_observations
        reward = EnvDynamicsUtil.reward_function(net_outcome=net_outcome, env_config=env_config, action=a)

        # Emulate detection
        done, d_reward = EnvDynamicsUtil.emulate_detection(net_outcome=net_outcome, action=a, env_config=env_config)
        if done:
            reward = d_reward
        s_prime.attacker_obs_state.detected = done

        # Simulate detection
        if not done:
            s_prime.attacker_obs_state.detected = done
            done, d_reward = SimulatorUtil.simulate_detection(a=a, env_config=env_config)
            if done:
                reward = d_reward

        s_prime.attacker_obs_state.detected = done
        return s_prime, reward, done


    @staticmethod
    def execute_ssh_backdoor(s: EnvState, a: AttackerAction, env_config: PyCREnvConfig) -> Tuple[EnvState, float, bool]:
        """
        Simulates the action of installing a SSH backdoor on a machine

        :param s: the environment state
        :param a: the action to take
        :param env_config: the environment configuration
        :return: s_prime, reward, done
        """
        new_machines = []

        for machine in s.attacker_obs_state.machines:
            if machine.logged_in and machine.tools_installed:
                m = machine.copy()
                m.backdoor_installed = True
                m.backdoor_tried = True
                new_machines.append(m)

        net_outcome = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, new_machines,
                                                   env_config=env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = net_outcome.attacker_machine_observations
        reward = EnvDynamicsUtil.reward_function(net_outcome=net_outcome, env_config=env_config, action=a)

        # Emulate detection
        done, d_reward = EnvDynamicsUtil.emulate_detection(net_outcome=net_outcome, action=a, env_config=env_config)
        if done:
            reward = d_reward
        s_prime.attacker_obs_state.detected = done

        # Simulate detection
        if not done:
            s_prime.attacker_obs_state.detected = done
            done, d_reward = SimulatorUtil.simulate_detection(a=a, env_config=env_config)
            if done:
                reward = d_reward

        return s_prime, reward, done