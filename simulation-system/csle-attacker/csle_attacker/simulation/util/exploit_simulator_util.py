import csle_common.constants.constants as constants
from csle_common.dao.emulation_config.network_service import NetworkService
from csle_common.dao.emulation_config.transport_protocol import TransportProtocol
from csle_common.dao.emulation_config.credential import Credential
from csle_common.dao.observation.common.port_observation_state import PortObservationState
from csle_common.dao.observation.common.vulnerability_observation_state import VulnerabilityObservationState
from csle_common.dao.emulation_config.emulation_env_state import EmulationEnvState
from csle_common.dao.emulation_config.emulation_env_config import EmulationEnvConfig
from csle_common.dao.action.attacker.attacker_action import AttackerAction
from csle_common.dao.observation.attacker.attacker_machine_observation_state import AttackerMachineObservationState
from csle_common.dao.action.attacker.attacker_action_outcome import AttackerActionOutcome
from csle_common.util.env_dynamics_util import EnvDynamicsUtil
from csle_attacker.simulation.util.simulator_util import SimulatorUtil


class ExploitSimulatorUtil:
    """
    Class containing utility functions for simulating exploit actions
    """

    @staticmethod
    def simulate_exploit_helper(s: EmulationEnvState, a: AttackerAction,
                                emulation_env_config: EmulationEnvConfig, vuln_name : str) -> EmulationEnvState:
        """
        Helper function for simulating dictionary scans against some service and with the constraint that
        only username-password combinations where username==password are tried.

        :param s: the current environment state
        :param a: the scan action to take
        :param emulation_env_config: the emulation environment configuration
        :param vuln_name: name of the vulnerability
        :return: s_prime
        """

        # Exploit on a single host
        if not a.subnet:
            return ExploitSimulatorUtil.simulate_exploit_single_host_helper(
                s=s, a=a, emulation_env_config=emulation_env_config, vuln_name=vuln_name)
        # Scan action on a whole subnet
        else:
            return ExploitSimulatorUtil.simulate_exploit_subnet_helper(s=s, a=a, emulation_env_config=emulation_env_config,
                                                                       vuln_name=vuln_name)

    @staticmethod
    def simulate_exploit_single_host_helper(s: EmulationEnvState, a: AttackerAction,
                                            emulation_env_config: EmulationEnvConfig,
                                            vuln_name: str) -> EmulationEnvState:
        """
        Helper for simulating exploits against a single host

        :param s: the current environment state
        :param a: the scan action to take
        :param emulation_env_config: the emulation environment configuration
        :param vuln_name: name of the vulnerability
        :return: s_prime
        """
        reachable_nodes = SimulatorUtil.reachable_nodes(state=s, emulation_env_config=emulation_env_config)

        new_m_obs = None
        for c in emulation_env_config.containers_config.containers:
            for ip in a.ips:
                if ip in c.get_ips() and ip in reachable_nodes:
                    new_m_obs = AttackerMachineObservationState(ips=c.get_ips())
                    new_m_obs.reachable = emulation_env_config.containers_config.get_reachable_ips(container=c)
                    vuln_match = False
                    vuln_service = None
                    for vuln in emulation_env_config.vuln_config.get_vulnerabilities(ips=c.get_ips()):
                        if vuln.name == vuln_name:
                            vuln_obs = VulnerabilityObservationState(name=vuln.name, port=vuln.port,
                                                                     protocol=vuln.protocol, cvss=vuln.cvss,
                                                                     service=vuln.service,
                                                                     credentials=vuln.credentials)
                            new_m_obs.cve_vulns.append(vuln_obs)
                            if a.action_outcome == AttackerActionOutcome.SHELL_ACCESS:
                                new_m_obs.shell_access = True
                                new_m_obs.untried_credentials = True
                                new_m_obs.shell_access_credentials = vuln.credentials
                            elif a.action_outcome == AttackerActionOutcome.PRIVILEGE_ESCALATION_ROOT:
                                new_m_obs.root = True

                            if a.backdoor:
                                new_m_obs.backdoor_installed = True
                                new_m_obs.backdoor_tried = True

                            vuln_match = True
                            vuln_service = vuln.service

                    if vuln_match:
                        c_services = emulation_env_config.services_config.get_services_for_ips(ips=c.get_ips())
                        for service in c_services:
                            if service.name == vuln_service:
                                port_obs = PortObservationState(port=service.port, open=True, service=service.name,
                                                                protocol=service.protocol)
                                new_m_obs.ports.append(port_obs)

                        # Samba Login
                        if vuln_name == constants.SAMBA.VULNERABILITY_NAME:
                            new_m_obs.root = True
                            service_names = list(map(lambda x: x.name, c_services))
                            if constants.SSH.SERVICE_NAME not in service_names:
                                c_services.append(NetworkService(
                                    protocol=TransportProtocol.TCP, port=constants.SSH.DEFAULT_PORT,
                                    name=constants.SSH.SERVICE_NAME))

                            for service in c_services:
                                if service.name == constants.SSH.SERVICE_NAME:
                                    samba_credentials_exist = False
                                    for cred in service.credentials:
                                        if (cred.service == constants.SSH.SERVICE_NAME
                                            and cred.username == constants.SAMBA.BACKDOOR_USER
                                            and cred.pw == constants.SAMBA.BACKDOOR_PW):
                                            samba_credentials_exist = True
                                    if not samba_credentials_exist:
                                        service.credentials.append(Credential(
                                            service=constants.SSH.SERVICE_NAME,
                                            username=constants.SAMBA.BACKDOOR_USER,
                                            pw=constants.SAMBA.BACKDOOR_PW,
                                            port = constants.SSH.DEFAULT_PORT,
                                            protocol=TransportProtocol.TCP))

                    new_m_obs = EnvDynamicsUtil.exploit_tried_flags(a=a, m_obs=new_m_obs)
                    break
        new_machines_obs = s.attacker_obs_state.machines
        if new_m_obs is not None:
            new_machines_obs = []
            merged = False
            for o_m in s.attacker_obs_state.machines:
                # Machine was already known, merge state
                if o_m.ips == a.ips:
                    attacker_machine_observation = EnvDynamicsUtil.merge_new_machine_obs_with_old_machine_obs(
                        o_m, new_m_obs, action=a)
                    new_machines_obs.append(attacker_machine_observation)
                    merged = True
                else:
                    new_machines_obs.append(o_m)
            # New machine, was not known before
            if not merged:
                new_machines_obs.append(new_m_obs)
        s_prime = s
        s_prime.attacker_obs_state.machines = new_machines_obs
        return s_prime

    @staticmethod
    def simulate_exploit_subnet_helper(s: EmulationEnvState, a: AttackerAction,
                                       emulation_env_config: EmulationEnvConfig,
                                       vuln_name: str) -> EmulationEnvState:
        """
        Helper for simulating exploits against an entire subnet

        :param s: the current environment state
        :param a: the scan action to take
        :param emulation_env_config: the emulation environment configuration
        :param vuln_name: name of the vulnerability
        :return: s_prime
        """
        reachable_nodes = SimulatorUtil.reachable_nodes(state=s, emulation_env_config=emulation_env_config)

        new_m_obs = None
        new_m_obs = []
        for c in emulation_env_config.containers_config.containers:
            if not c.get_ips() in reachable_nodes:
                continue
            m_obs = AttackerMachineObservationState(ips=c.get_ips())
            m_obs.reachable = emulation_env_config.containers_config.get_reachable_ips(container=c)
            vulnerable_services = []
            for vuln in emulation_env_config.vuln_config.get_vulnerabilities(ips=c.get_ips()):
                if vuln.name == vuln_name:
                    vuln_obs = VulnerabilityObservationState(name=vuln.name, port=vuln.port,
                                                             protocol=vuln.protocol, cvss=vuln.cvss,
                                                             service=vuln.service, credentials=vuln.credentials)
                    if a.action_outcome == AttackerActionOutcome.SHELL_ACCESS:
                        m_obs.shell_access = True
                        m_obs.untried_credentials = True
                        m_obs.shell_access_credentials = vuln.credentials
                    m_obs.cve_vulns.append(vuln_obs)
                    vulnerable_services.append(vuln.name)

            for service in emulation_env_config.services_config.get_services_for_ips(ips=c.get_ips()):
                match = False
                for vuln_service in vulnerable_services:
                    if service.name == vuln_service:
                        match = True
                if match:
                    port_obs = PortObservationState(port=service.port, open=True,
                                                    service=service.name,
                                                    protocol=service.protocol)
                    m_obs.ports.append(port_obs)
            m_obs = EnvDynamicsUtil.exploit_tried_flags(a=a, m_obs=m_obs)
            new_m_obs.append(m_obs)

        attacker_machine_observations = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, new_m_obs,
                                                             emulation_env_config=emulation_env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = attacker_machine_observations
        return s_prime
