import csle_common.constants.constants as constants
from csle_common.dao.emulation_config.emulation_env_state import EmulationEnvState
from csle_common.dao.emulation_action.attacker.emulation_attacker_action import EmulationAttackerAction
from csle_common.dao.emulation_observation.attacker.emulation_attacker_machine_observation_state \
    import EmulationAttackerMachineObservationState
from csle_common.util.env_dynamics_util import EnvDynamicsUtil
from csle_attacker.simulation.util.shell_simulator_util import ShellSimulatorUtil


class PostExploitSimulator:
    """
    Class that implements functionality for simulating post-exploit actions
    """

    @staticmethod
    def simulate_ssh_login(s: EmulationEnvState, a: EmulationAttackerAction) \
            -> EmulationEnvState:
        """
        Simulates an action of logging in to a SSH server

        :param s: the environment state
        :param a: the action to take
        :return: s_prime
        """
        s_prime = ShellSimulatorUtil.simulate_service_login_helper(s=s, a=a, service_name=constants.SSH.SERVICE_NAME)
        return s_prime

    @staticmethod
    def simulate_ftp_login(s: EmulationEnvState, a: EmulationAttackerAction) -> EmulationEnvState:
        """
        Simulates an action of logging in to a FTP server

        :param s: the environment state
        :param a: the action to take
        :return: s_prime
        """
        s_prime = ShellSimulatorUtil.simulate_service_login_helper(s=s, a=a, service_name=constants.FTP.SERVICE_NAME)
        return s_prime

    @staticmethod
    def simulate_telnet_login(s: EmulationEnvState, a: EmulationAttackerAction) -> EmulationEnvState:
        """
        Simulates an action of logging in to a FTP server

        :param s: the environment state
        :param a: the action to take
        :return: s_prime, reward, done
        """
        s_prime = ShellSimulatorUtil.simulate_service_login_helper(s=s, a=a, service_name=constants.TELNET.SERVICE_NAME)
        return s_prime

    @staticmethod
    def simulate_bash_find_flag(s: EmulationEnvState, a: EmulationAttackerAction) -> EmulationEnvState:
        """
        Simulates the action of searching the file system for a flag

        :param s: the environment state
        :param a: the action to take
        :return: s_prime
        """
        new_obs_machines = []
        for c in emulation_env_config.containers_config.containers:
            new_m_obs = None
            logged_in = False
            logged_in_m = None
            for o_m in s.attacker_obs_state.machines:
                for ip in o_m.ips:
                    if ip in c.get_ips():
                        logged_in = o_m.logged_in
                        logged_in_m = o_m
                        break

            if logged_in:
                new_m_obs = EmulationAttackerMachineObservationState(ips=c.get_ips())
                for flag in s.emulation_env_config.flags_config.get_flags_for_ips(ips=c.get_ips()):
                    if flag.requires_root and logged_in_m.root:
                        new_m_obs.flags_found.add(flag)
                    elif not flag.requires_root:
                        new_m_obs.flags_found.add(flag)
                new_m_obs.filesystem_searched = True
                new_obs_machines.append(new_m_obs)
        attacker_machine_observations = EnvDynamicsUtil.merge_new_obs_with_old(
            s.attacker_obs_state.machines,  new_obs_machines, emulation_env_config=s.emulation_env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = attacker_machine_observations
        return s_prime


    @staticmethod
    def execute_install_tools(s: EmulationEnvState, a: EmulationAttackerAction) -> EmulationEnvState:
        """
        Simulates the action of install tools needed to install backdoors on a compromised machine

        :param s: the environment state
        :param a: the action to take
        :return: s_prime
        """
        new_machines = []

        for machine in s.attacker_obs_state.machines:
            if machine.logged_in and machine.root:
                m = machine.copy()
                m.tools_installed = True
                new_machines.append(m)

        attacker_machine_observations = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, new_machines,
                                                             emulation_env_config=s.emulation_env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = attacker_machine_observations
        return s_prime


    @staticmethod
    def execute_ssh_backdoor(s: EmulationEnvState, a: EmulationAttackerAction) -> EmulationEnvState:
        """
        Simulates the action of installing a SSH backdoor on a machine

        :param s: the environment state
        :param a: the action to take
        :return: s_prime
        """
        new_machines = []

        for machine in s.attacker_obs_state.machines:
            if machine.logged_in and machine.tools_installed:
                m = machine.copy()
                m.backdoor_installed = True
                m.backdoor_tried = True
                new_machines.append(m)

        attacker_machine_observations = EnvDynamicsUtil.merge_new_obs_with_old(s.attacker_obs_state.machines, new_machines,
                                                             emulation_env_config=s.emulation_env_config, action=a)
        s_prime = s
        s_prime.attacker_obs_state.machines = attacker_machine_observations

        return s_prime